<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AutoUpdater自动更新客户端</title>
    <url>/2021/03/19/AutoUpdater%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="安装-NuGet-包"><a href="#安装-NuGet-包" class="headerlink" title="安装 NuGet 包"></a>安装 NuGet 包</h2><pre><code>在Visio studio中右击解决方案，选择管理NuGet包，搜索安装Autoupdater.NET.Official。
</code></pre>
<h2 id="工作简介"><a href="#工作简介" class="headerlink" title="工作简介"></a>工作简介</h2><pre><code>    从服务器下载包含更新文件的XML文件，从中获取软件的最新版本信息。如果软件的最新版本大于用户PC上安装的当前软件版本，则会向用户显示更新对话框。当然，也可以设置按钮事件进行点击下载更新文件。如果文件是压缩包，会自动将压缩包的内容解压缩到应用程序目录。
</code></pre>
<h2 id="XML-文件"><a href="#XML-文件" class="headerlink" title="XML 文件"></a>XML 文件</h2><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span></span><br><span class="line">&lt; item &gt;</span><br><span class="line">    &lt; version &gt; 2.0.0.0 &lt;/ version &gt;</span><br><span class="line">    &lt; url &gt; https://www.cnblogs.com&lt;/ url &gt;</span><br><span class="line">    &lt; changelog &gt; https://www.cnblogs.com &lt;/ changelog &gt;</span><br><span class="line">    &lt; mandatory &gt; false &lt;/ mandatory &gt;</span><br><span class="line">&lt;/ item &gt;</span><br></pre></td></tr></table></figure>

如上所示：
    version(必填)：格式为X.X.X.X的版本标记。
    url(必填)：最新版本安装程序文件的url。
    changelog(可选)：程序更改日志的url。
    mandatory(可选)：强制更新，将跳过信息和稍后更新按钮隐藏。
选择使用以下代码将跳过update对话框，自动下载更新：

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mandatory</span> <span class="attr">mode</span>=<span class="string">&quot;2&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">mandatory</span>&gt;</span></span><br></pre></td></tr></table></figure>

    args(可选)：为安装提供命令行参数，参数可以包含%path%，用以替换正在执行的应用程序所在目录的路径。
    checksum(可选)：更新文件的校验和，用以检验文件的完整性，algorithm属性指定算法，支持 MD5,SHA1,SHA256,SHA384,SHA512。

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">checksum</span> <span class="attr">algorithm</span>=<span class="string">&quot;MD5&quot;</span>&gt;</span>Update file Checksum<span class="tag">&lt;/<span class="name">checksum</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="窗体代码"><a href="#窗体代码" class="headerlink" title="窗体代码"></a>窗体代码</h2><pre><code><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> AutoUpdaterDotNET;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//XML文件地址</span></span><br><span class="line">            AutoUpdater.Start(<span class="string">&quot;https://www.cnblogs.com&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p>[<a href="https://github.com/ravibpatel/AutoUpdater.NET]">https://github.com/ravibpatel/AutoUpdater.NET]</a></p>
]]></content>
      <categories>
        <category>.Net</category>
        <category>Winform</category>
      </categories>
      <tags>
        <tag>AutoUpdater</tag>
        <tag>客户端</tag>
      </tags>
  </entry>
  <entry>
    <title>CefSharp创建客户端</title>
    <url>/2021/03/19/CefSharp%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="安装-NuGet-包"><a href="#安装-NuGet-包" class="headerlink" title="安装 NuGet 包"></a>安装 NuGet 包</h2><pre><code>在Visio studio中右击解决方案，选择管理NuGet包，搜索安装CefSharp.WinForms。
</code></pre>
<h2 id="配置工作"><a href="#配置工作" class="headerlink" title="配置工作"></a>配置工作</h2><pre><code>(1)首先右击项目选择属性，在&quot;生成&quot;选项中将&quot;首选32位&quot;勾上。

(2)其次在项目文件目录下找到&quot;项目名称.csproj&quot;文件，在第一个PropertyGroup中添加以下代码：

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CefSharpAnyCpuSupport</span>&gt;</span>true<span class="tag">&lt;/<span class="name">CefSharpAnyCpuSupport</span>&gt;</span></span><br></pre></td></tr></table></figure>

(3)最后修改App.config文件，和&lt;startup&gt;标签并列地位，添加以下代码：

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">runtime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assemblyBinding</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">probing</span> <span class="attr">privatePath</span>=<span class="string">&quot;x86&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assemblyBinding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">runtime</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="窗体代码"><a href="#窗体代码" class="headerlink" title="窗体代码"></a>窗体代码</h2><pre><code><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> CefSharp;</span><br><span class="line"><span class="keyword">using</span> CefSharp.WinForms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">embebbedChromium</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> ChromiumWebBrowser chromeBrowser;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            <span class="comment">// 初始化全局组件后启动浏览器</span></span><br><span class="line">            InitializeChromium();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitializeChromium</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CefSettings settings = <span class="keyword">new</span> CefSettings();</span><br><span class="line">            <span class="comment">//按照设置初始化cef</span></span><br><span class="line">            Cef.Initialize(settings);</span><br><span class="line">            <span class="comment">// 创建一个浏览器组件</span></span><br><span class="line">            chromeBrowser = <span class="keyword">new</span> ChromiumWebBrowser(<span class="string">&quot;http://baidu.com&quot;</span>);</span><br><span class="line">            <span class="comment">// 将其添加到表单并将其填充到表单窗口</span></span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(chromeBrowser);</span><br><span class="line">            chromeBrowser.Dock = DockStyle.Fill;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_FormClosing</span>(<span class="params"><span class="built_in">object</span> sender, FormClosingEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Cef.Shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p>[<a href="https://ourcodeworld.com/articles/read/173/how-to-use-cefsharp-chromium-embedded-framework-csharp-in-a-winforms-application]">https://ourcodeworld.com/articles/read/173/how-to-use-cefsharp-chromium-embedded-framework-csharp-in-a-winforms-application]</a></p>
]]></content>
      <categories>
        <category>.Net</category>
        <category>Winform</category>
      </categories>
      <tags>
        <tag>客户端</tag>
        <tag>CefSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类型转换工具类（持续更新）</title>
    <url>/2021/03/19/Java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  将项目中用到的类型转换做个记录。</p>
<h2 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeUtil</span> </span>&#123;</span><br><span class="line"> <span class="comment">// [start]字符串转各种格式</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转日期(格式:&quot;yyyyMMdd&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">StrToDateFirst</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">  Date date = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   date = format.parse(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转日期(格式:&quot;dd/MM/yyyy&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">StrToDateSecond</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;dd/MM/yyyy&quot;</span>);</span><br><span class="line">  Date date = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   date = format.parse(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转日期(格式:&quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">StrToDateThird</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">  Date date = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   date = format.parse(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转日期(格式:&quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">StrToDateFourth</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">  Date date = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   date = format.parse(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转Integer</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">StrToInteger</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  Integer integer = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   integer = Integer.valueOf(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> integer;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转Double</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">StrToDouble</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  Double double1 = <span class="number">0.00</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   double1 = Double.parseDouble(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> double1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转时间戳</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Timestamp <span class="title">StrToTimeStamp</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  Timestamp timestamp = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   timestamp = Timestamp.valueOf(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> timestamp;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转BigDecimal</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">StrTiBigdecimal</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  BigDecimal bigDecimal = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   bigDecimal = <span class="keyword">new</span> BigDecimal(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bigDecimal;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// [end]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
        <tag>Utils</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Batch学习笔记（一）</title>
    <url>/2021/03/19/Spring-Batch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Spring-Batch-简介"><a href="#Spring-Batch-简介" class="headerlink" title="Spring Batch 简介"></a>Spring Batch 简介</h2><p>Spring Batch 提供了可重复使用的功能，用来处理大量数据。包括记录、跟踪，事务管理，作业处理统计，作业重启，跳过和资源管理。<br>此外还提供了更高级的技术服务和功能，通过优化和分区技术实现极高容量和高性能的批处理作业。</p>
<h2 id="Spring-Batch-使用场景"><a href="#Spring-Batch-使用场景" class="headerlink" title="Spring Batch 使用场景"></a>Spring Batch 使用场景</h2><p>(1)一般的批处理程序</p>
<p>·从数据库，文件或者队列中读取大量数据<br>·处理读取到的数据<br>·将处理完成的数据保存到文件，数据库</p>
<p>(2)业务场景</p>
<p>·定期提交批处理<br>·并发批处理，并行处理 Job<br>·分阶段的企业消息驱动处理<br>·大规模并行批处理<br>·失败后手动或预定重启<br>·依赖步骤的顺序处理<br>·部分处理，跳过记录<br>·整批交易，适用于批量较小或现有存储过程/脚本的情况</p>
<h2 id="Spring-Batch-主要组成部分"><a href="#Spring-Batch-主要组成部分" class="headerlink" title="Spring Batch 主要组成部分"></a>Spring Batch 主要组成部分</h2><p>·JobRepository，用来注册 job 的容器<br>·JobLauncher，用来启动 job 的接口<br>·Job，实际执行的任务，包含一个或多个 Step<br>·Step，step 包含 ItemReader、ItemProcessor 和 ItemWriter<br>·ItemReader，用来读取数据的接口<br>·ItemProcessor，用来处理数据的接口<br>·ItemWriter，用来输出数据的接口<br>以上 Spring Batch 的主要组成部分只需要注册成 Spring 的 Bean 即可。批处理的配置类上需要使用@EnabelBatchProcessing。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>(1)监听器 JobListener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobListener</span> <span class="keyword">implements</span> <span class="title">JobExecutionListener</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeJob</span><span class="params">(JobExecution jobExecution)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Job执行前需要执行的操作</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterJob</span><span class="params">(JobExecution jobExecution)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Job执行完成后需要执行的操作</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)配置类 DataBatchConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBatchConfiguration</span></span>&#123;</span><br><span class="line"> <span class="comment">// 用于构建Job</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> JobBuilderFactory jobBuilderFactory;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 用于构建Step</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> StepBuilderFactory stepBuilderFactory;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 监听器</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> JobListener jobListener;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ItemReader(使用的其中一种读取方式)</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> RepositoryItemReader readerData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ItemWriter</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> ItemReader writerData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Job</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Job <span class="title">dataHandleJob</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> jobBuilderFactory.get(<span class="string">&quot;dataHandleJob&quot;</span>).incrementer(<span class="keyword">new</span> RunIdIncrementer()).start(getDataStep())</span><br><span class="line">   .listener(jobListener).build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Step</span></span><br><span class="line"> <span class="comment">// User:要处理的对象</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Step <span class="title">getTDistSellOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> stepBuilderFactory.get(<span class="string">&quot;getData&quot;</span>).&lt;User, User&gt;chunk(<span class="number">10000</span>) <span class="comment">// 一次commit数据的数量</span></span><br><span class="line">   .faultTolerant().retryLimit(<span class="number">3</span>)</span><br><span class="line">   .retry(Exception.class)</span><br><span class="line">   .skipLimit(<span class="number">100</span>)            <span class="comment">// 发生异常时，允许重试的次数</span></span><br><span class="line">   .skip(Exception.class)</span><br><span class="line">   .reader(readerData)              <span class="comment">// reader</span></span><br><span class="line">   .writer(writerData).build();        <span class="comment">// writer</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)读取类 ReaderStep</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderStep</span></span>&#123;</span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> EntityManagerFactory emf;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span> <span class="function">RepositoryItemReader&lt;User&gt; <span class="title">readerData</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 排序map(读取数据按照ID进行正序排列)</span></span><br><span class="line">  Map&lt;String,Sort.Direction&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;id&quot;</span>,sort.Direction.ASC);</span><br><span class="line">  <span class="comment">// SQL语句所需参数LIST</span></span><br><span class="line">  List&lt;String&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  params.add(<span class="string">&quot;2019-03-20&quot;</span>);</span><br><span class="line">  RepositoryItemReader&lt;User&gt; repositoryItemReader = <span class="keyword">new</span> <span class="keyword">new</span> RepositoryItemReader&lt;&gt;();</span><br><span class="line">  <span class="comment">// Set Repository</span></span><br><span class="line">  repositoryItemReader.setRepository(userRepository);</span><br><span class="line">  <span class="comment">// Set PageSize(没有会报错)</span></span><br><span class="line">  repositoryItemReader.setPageSize(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">// Set Repository Method</span></span><br><span class="line">  repositoryItemReader.setMethodName(<span class="string">&quot;findByDateLike&quot;</span>);</span><br><span class="line">  <span class="comment">// Set 参数List</span></span><br><span class="line">  repositoryItemReader.setArguments(params);</span><br><span class="line">  <span class="comment">// Set 排序Map</span></span><br><span class="line">  repositoryItemReader.setSort(map);</span><br><span class="line">  <span class="keyword">return</span> repositoryItemReader;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)写出类 WriterStep</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterStep</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RepositoryItemWriter&lt;User&gt; <span class="title">writerData</span><span class="params">()</span></span>&#123;</span><br><span class="line">  RepositoryItemWriter&lt;User&gt; repositoryItemWriter = <span class="keyword">new</span> RepositoryItemWriter&lt;&gt;();</span><br><span class="line">  repositoryItemWriter.setRepository(userRepository);</span><br><span class="line">  repositoryItemWriter.setMethodName(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> repositoryItemWriter;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><p>[<a href="https://www.cnblogs.com/ealenxie/p/9647703.html]">https://www.cnblogs.com/ealenxie/p/9647703.html]</a></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Batch</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue函数防抖和函数节流</title>
    <url>/2021/03/18/Vue%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</li>
<li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li>
<li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li>
</ul>
<h3 id="实现方法，防抖重在清零"><a href="#实现方法，防抖重在清零" class="headerlink" title="实现方法，防抖重在清零"></a>实现方法，防抖重在清零</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            f(..args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><code>scroll</code>事件，每隔一秒计算一次位置信息等</li>
<li>浏览器播放事件，每隔一秒计算一次进度信息等</li>
<li>input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求</li>
</ul>
<h4 id="实现方法，节流重在开关锁"><a href="#实现方法，节流重在开关锁" class="headerlink" title="实现方法，节流重在开关锁"></a>实现方法，节流重在开关锁</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">f, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">..args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            f(..args)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误触发多次。代码重在清零<code>clearTimeout</code></li>
<li>节流：控制流量，单位时间内事件只能触发一次，如果服务器端的限流即 Rate Limit。代码实现重在开锁关锁<code>timer=timeout；timer=null</code></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title>WinForm设置控件居中</title>
    <url>/2021/03/19/WinForm%E8%AE%BE%E7%BD%AE%E6%8E%A7%E4%BB%B6%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<h2 id="简单阐述"><a href="#简单阐述" class="headerlink" title="简单阐述"></a>简单阐述</h2><pre><code>在C#的WinForm里面，原生控件是没有居中属性的，故通过重写OnResize(EventArgs e)方法，通过计算，重新定位控件位置。
</code></pre>
<h2 id="以-Label-控件为例"><a href="#以-Label-控件为例" class="headerlink" title="以 Label 控件为例"></a>以 Label 控件为例</h2><pre><code>(1)将label的AutoSize属性设置为false；Dock属性设置为fill；TextAlign属性设置为MiddleCenter。
(2)重写居中的代码如下：
</code></pre>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResize</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnResize(e);</span><br><span class="line">            <span class="built_in">int</span> x = (<span class="built_in">int</span>)(<span class="number">0.5</span> * (<span class="keyword">this</span>.Width - label1.Width));</span><br><span class="line">            <span class="built_in">int</span> y = label1.Location.Y;</span><br><span class="line">            label1.Location = <span class="keyword">new</span> System.Drawing.Point(x,y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p>[<a href="https://blog.csdn.net/mingyueyixi/article/details/55035935]">https://blog.csdn.net/mingyueyixi/article/details/55035935]</a></p>
]]></content>
      <categories>
        <category>. Net</category>
        <category>Winform</category>
      </categories>
      <tags>
        <tag>控件</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows端口被占用解决方法</title>
    <url>/2021/03/19/Windows%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Error-场景"><a href="#Error-场景" class="headerlink" title="Error 场景"></a>Error 场景</h2><p>启动 Java 项目失败，控制台显示</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Error starting ApplicationContext. To display the conditions report`re-run your application with &#x27;debug&#x27; enabled.</span><br><span class="line"></span><br><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">The Tomcat connector configured to listen on port 8080 failed to start. The port may already be in use or the connector may be misconfigured.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Verify the connector&#x27;s configuration, identify and stop any process that&#x27;s listening on port 8080, or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li><p>查看那些进程占用了我们的端口号<code>8080</code></p>
<p>打开 Windows 控制台，输入命令</p>
</li>
</ul>
<p><code>netstat -nao | findstr &quot;8080&quot;</code></p>
<p>可以看到占用 <code>8080</code> 端口的进程 PID 为 <code>8404</code></p>
<ul>
<li><p>杀死相应进程：</p>
<p>在 Windows 控制台，继续输入命令</p>
</li>
</ul>
<p><code>taskkill /pid 8404 /f</code></p>
<p><img src="https://img.imgdb.cn/item/605440cc524f85ce2903d864.jpg" alt="avatar"></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>端口占用</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2021/03/18/about/</url>
    <content><![CDATA[<h2 id="张凯"><a href="#张凯" class="headerlink" title="张凯"></a>张凯</h2><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h2 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h2>]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title>一款智能的日期解析工具</title>
    <url>/2021/03/19/%E4%B8%80%E6%AC%BE%E6%99%BA%E8%83%BD%E7%9A%84%E6%97%A5%E6%9C%9F%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Java</code> 中日期、时间相关的类相当的多，并且分不同的版本提供了不同的实现，包括 <code>Date</code> 、 <code>Calendar</code> 、 <code>LocalDateTime</code> 、 <code>ZoneDateTime</code> 、 <code>OffsetDateTime</code> 等等。针对这些时间类型又通过 <code>SimpleDateFormat</code> 和 <code>DateTimeFormatter</code> 实现不同的日期与字符串之间的格式化和解析。</p>
<p>为了应对各种各样的日期解析，我们通常会封装类似于 <code>DateUtils</code> 的工具类，专门用来处理日期字符串的解析，同时为了兼容不同格式的日期字符串，又需要预先枚举出可能用到的日期格式。这种传统的 <code>DateUtils</code> 通常会面临性能与兼容性的两难问题。</p>
<p>而本文要介绍的，是一个截然不同的日期解析工具 <code>dateparser</code> ，它可以智能地解析几百上千种任意格式的日期字符串，更为难得的是它的性能同样非常出色。</p>
<h2 id="DateUtils-的两难问题"><a href="#DateUtils-的两难问题" class="headerlink" title="DateUtils 的两难问题"></a>DateUtils 的两难问题</h2><p>一个比较典型的日期解析函数类似这样（这是 <code>commons-lang3</code> 在其 <code>DateUtils</code> 中提供的函数）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parseDate</span><span class="params">(<span class="keyword">final</span> String str, <span class="keyword">final</span> String... parsePatterns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseDate(str, <span class="keyword">null</span>, parsePatterns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种日期解析函数的内部逻辑，往往是根据一批 <code>DATE_FORMAT</code> 轮番尝试，通过异常重试的方式试出来唯一匹配的格式。这种简单粗暴的方式，事实上存在着一个两难问题。</p>
<p>首先，我们很难穷举出全部可能出现的日期格式，年月日的分隔符、排列次序、时分秒、是否有毫秒、时区处理、PM 与 AM 的支持等等，罗列出来的话不计其数。</p>
<p>其次，异常重试的方式存在一些性能损耗，据我粗略测算，在 MBP 硬件环境中异常中断大概需要消耗 <code>2</code> 微秒，而一次日期解析可能消耗 <code>0.75</code> 微秒。如果提供的 <code>parsePatterns</code> 数量很多，则解析一个日期字符串的循环重试的最终耗时甚至会超过 <code>Redis</code> 读写操作。</p>
<p>那么，有没有办法既可以支持无数多个不规则的日期字符串，同时也没有性能问题的技术方案呢？</p>
<h2 id="dateparser"><a href="#dateparser" class="headerlink" title="dateparser"></a><code>dateparser</code></h2><p>这就是解决日期字符串解析的灵丹妙药，它是一个高性能且非常智能的 datetime 字符串解析工具。</p>
<p>为了实现高性能与可扩展性，它并没有采用 <code>SimpleDateFormat</code> 或 <code>DateTimeFormatter</code> ，而是正则表达式。通过预定义的正则表达式来自动地捕捉不同格式的日期片段，它可以自动抽取出字符串中存在的 <code>year</code> , <code>month</code> , <code>day</code> , <code>hour</code> , <code>minute</code> , <code>second</code> , <code>zone</code> 等熟悉。</p>
<p>这些预定义的正则表达式片段包括：</p>
<p><code>(?&lt;week&gt;%s)\W*</code> 可以将 <code>Monday</code> 解析为 <code>week</code></p>
<p><code>?(?&lt;year&gt;\d&#123;4&#125;)$</code> 可以将 <code>2019</code> 解析为 <code>year</code></p>
<p><code>^(?&lt;year&gt;\d&#123;4&#125;)(?&lt;month&gt;\d&#123;2&#125;)$</code> 可以抽取出 <code>201909</code> 内部的 <code>year</code> 和 <code>month</code></p>
<p><code>?(?&lt;hour&gt;\d&#123;1,2&#125;) o’clock\W*</code> 可以将 <code>12 o’clock</code> 解析为 <code>hour</code></p>
<p>更多规则参见 <code>DateParserBuilder.java</code></p>
<p>如此多的正则表达式，会不会也存在性能隐患呢？如果使用的是 <code>java.util.regex</code> 包来进行循环匹配，随着规则增加，确实会有性能问题。<br>但是 <code>dateparser</code> 使用 <code>retree</code> 将预定义的一大批正则表达式合并为一颗树，也就是正则匹配树。它可以非常快速地对一大批正则表达式执行并行匹配，内部结构可以理解为字典树，但是树中的节点并不是字母，而是正则匹配节点。</p>
<h2 id="安装-Maven-依赖"><a href="#安装-Maven-依赖" class="headerlink" title="安装 Maven 依赖"></a>安装 Maven 依赖</h2><p>可以通过此 <code>maven</code> 坐标引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sisyphsu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dateparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><code>dateparser</code> 提供了一个 <code>DateParserUtils</code> 工具类，可以直接使用它将字符串解析为 <code>Date</code> 、 <code>Calendar</code> 、 <code>LocalDateTime</code> 、 <code>OffsetDateTime</code> 等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = DateParserUtils.parseDate(<span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span>);</span><br><span class="line"><span class="comment">// Tue Jan 03 06:04:05 CST 2006</span></span><br><span class="line">Calendar calendar =</span><br><span class="line">DateParserUtils.parseCalendar(<span class="string">&quot;Fri Jul 03 2015 18:04:07 GMT+0100 (GMT Daylight Time)&quot;</span>);</span><br><span class="line"><span class="comment">// 2015-07-03T17:04:07Z</span></span><br><span class="line">LocalDateTime dateTime =</span><br><span class="line">DateParserUtils.parseDateTime(<span class="string">&quot;2019-09-20 10:20:30.12345678 +0200&quot;</span>);</span><br><span class="line"><span class="comment">// 2019-09-20T16:20:30.123456780</span></span><br><span class="line">OffsetDateTime offsetDateTime =</span><br><span class="line">DateParserUtils.parseOffsetDateTime(<span class="string">&quot;2015-09-30 18:48:56.35272715 +0000 UTC&quot;</span>);</span><br><span class="line"><span class="comment">// 2015-09-30T18:48:56.352727150Z</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，它会根据字符串中标明的 <code>TimeZon</code> e 或 <code>ZoneOffset</code> 自动进行偏移量转换。</p>
<h2 id="创建新-DateParser-实例"><a href="#创建新-DateParser-实例" class="headerlink" title="创建新 DateParser 实例"></a>创建新 DateParser 实例</h2><p>由于 <code>DateParser</code> 不是线程安全的，同时 <code>parse</code> 操作通常非常快速（1us），因此 <code>DateParserUtils</code> 内部直接维护了一个 <code>DateParser</code> 单例，然后通过 <code>synchronized</code> 进行并发控制。</p>
<p>如果你想在多线程中高频率、并发地使用它，就应该为不同的线程创建不同的 <code>DateParser</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateParser parser = DateParser.newBuilder().build();</span><br><span class="line">Date date = parser.parseDate(<span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span>);</span><br><span class="line"><span class="comment">// Tue Jan 03 06:04:05 CST 2006</span></span><br></pre></td></tr></table></figure>

<p><code>DateParser</code> 实例相当笨重一些，所以你应该尽量多的复用它以提高性能。</p>
<h2 id="MM-dd-与-dd-MM-的优先级"><a href="#MM-dd-与-dd-MM-的优先级" class="headerlink" title="MM/dd 与 dd/MM 的优先级"></a><code>MM/dd</code> 与 <code>dd/MM</code> 的优先级</h2><p>多数情况下， <code>dateparser</code> 可以按照规则自动地识别出字符串内部的 <code>month</code> 与 <code>day</code> 片段。</p>
<p>但是对于 <code>MM/dd/yy</code> 和 <code>dd/MM/yy</code> ，有时候它就难以区分了。因为世界上多数国家会使用 <code>dd/MM/yy</code> 作为日期的格式，但是也有少数国家会特立独行地使用 <code>MM/dd/yy</code> 作为日期格式，最典型的就是美帝国主义。</p>
<p>因此当 <code>dateparser</code> 遇到类似于 <code>7.8.2019</code> 这样的日期时，它就很难判断到底是 7 月 8 日还是 8 月 7 日。</p>
<p>为解决这个难题， <code>dateparser</code> 内部增加了一个名为 <code>preferMonthFirst</code> 的选项，用于辅助解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateParserUtils.preferMonthFirst(<span class="keyword">true</span>);</span><br><span class="line">DateParserUtils.parseCalendar(<span class="string">&quot;08.03.71&quot;</span>);</span><br><span class="line"><span class="comment">// 1971-08-03</span></span><br><span class="line">DateParserUtils.preferMonthFirst(<span class="keyword">false</span>);</span><br><span class="line">DateParserUtils.parseCalendar(<span class="string">&quot;08.03.71&quot;</span>);</span><br><span class="line"><span class="comment">// 1971-03-08</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，如果无法甄别月与日，则视为月在后。如果你指定了 <code>preferMonthFirst</code> 为 <code>true</code> ，则试为月在前。</p>
<h2 id="自定义-Parser"><a href="#自定义-Parser" class="headerlink" title="自定义 Parser"></a>自定义 Parser</h2><p>你可以使用 <code>DateParserBuilder</code> 构建自己的日期解析器，通过此 <code>builder</code> ，你可以自定义新的解析规则。</p>
<p>例如，如果你想支持 <code>【2019】</code> 这样的 <code>year</code> 字符串，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateParser parser = DateParser.newBuilder().addRule(<span class="string">&quot;【(?&lt;year&gt;\\d&#123;4&#125;)】&quot;</span>).build();</span><br><span class="line">Calendar calendar = parser.parseCalendar(<span class="string">&quot;【1991】&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span> calendar.get(Calendar.YEAR) == <span class="number">1991</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，正则表达式 <code>【(?&lt;year&gt;\\d&#123;4&#125;)】</code> 里面的 <code>year</code> 非常重要，它是 <code>dateparser</code> 内置的捕捉关键词。</p>
<p>你也可以增加更加灵活的解析规则，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateParser parser = DateParser.newBuilder()</span><br><span class="line">.addRule(<span class="string">&quot;民国(\\d&#123;3&#125;)年&quot;</span>, (input, matcher, dt) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> offset = matcher.start(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i0 = input.charAt(offset) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> i1 = input.charAt(offset + <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = input.charAt(offset + <span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dt.setYear(i0 * <span class="number">100</span> + i1 * <span class="number">10</span> + i2 + <span class="number">1911</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.build();</span><br><span class="line">Calendar calendar = parser.parseCalendar(<span class="string">&quot;民国101年&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span> calendar.get(Calendar.YEAR) == <span class="number">2012</span>;</span><br></pre></td></tr></table></figure>

<p>这个例子里面，新增了一个捕捉并解析 <code>民国xxx年</code> 的日期规则。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>首先，在单一日期格式下，对比一下 <code>dateparser</code> 与 <code>SimpleDateFormat</code> 的性能表现：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Benchmark               Mode  Cnt     Score    Error  Units</span><br><span class="line">SingleBenchmark.java    avgt    6   921.632 ± 12.299  ns/op</span><br><span class="line">SingleBenchmark.parser  avgt    6  1553.909 ± 70.664  ns/op</span><br></pre></td></tr></table></figure>

<p>可以看到，在日期格式固定且单一的情况下， <code>dateparser</code> 在性能上处于下风，这也在预料之中。</p>
<p>然后，在单一日期格式下，对比一下 <code>dateparser</code> 与 <code>DateTimeFormatter</code> 的性能表现：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Benchmark                       Mode  Cnt     Score    Error  Units</span><br><span class="line">SingleDateTimeBenchmark.java    avgt    6   654.553 ± 16.703  ns/op</span><br><span class="line">SingleDateTimeBenchmark.parser  avgt    6  1680.690 ± 34.214  ns/op</span><br></pre></td></tr></table></figure>

<p>可以看到， <code>DateTimeFormatter</code> 的性能表现确实比 S <code>impleDateFormat</code> 更加出色一些。同时 dateparser 的设计初衷是为了应对不规则日期格式，因此在固定格式匹配上存在劣势并不意外。</p>
<p>如果我们将日期格式增加为 16 种时，性能表现就不一样了：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Benchmark              Mode  Cnt      Score      Error  Units</span><br><span class="line">MultiBenchmark.format  avgt    6  47385.021 ± 1083.649  ns/op</span><br><span class="line">MultiBenchmark.parser  avgt    6  22852.113 ±  310.720  ns/op</span><br></pre></td></tr></table></figure>

<p>如果换算一下，无论日期格式是一种还是 16 中， <code>dateparser</code> 的性能始终维持在 <code>1.5us</code> ，说明它在算法上是非常稳定的，面对不同的场景不会有什么性能损失</p>
<h2 id="支持的日期格式（部分）"><a href="#支持的日期格式（部分）" class="headerlink" title="支持的日期格式（部分）"></a>支持的日期格式（部分）</h2><p>以下为 <code>dateparser</code> 在单元测试中完成测试解析的日期格式样例，具体可以参考源代码。同时需要注意的是，这个列表只是一个子集：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">May 8, 2009 5:57:51 PM</span><br><span class="line">oct 7, 1970</span><br><span class="line">oct 7, &#x27;70</span><br><span class="line">oct. 7, 1970</span><br><span class="line">oct. 7, 70</span><br><span class="line">Mon Jan  2 15:04:05 2006</span><br><span class="line">Mon Jan  2 15:04:05 MST 2006</span><br><span class="line">Mon Jan 02 15:04:05 -0700 2006</span><br><span class="line">Monday, 02-Jan-06 15:04:05 MST</span><br><span class="line">Mon, 02 Jan 2006 15:04:05 MST</span><br><span class="line">Tue, 11 Jul 2017 16:28:13 +0200 (CEST)</span><br><span class="line">Mon, 02 Jan 2006 15:04:05 -0700</span><br><span class="line">Thu, 4 Jan 2018 17:53:36 +0000</span><br><span class="line">Mon Aug 10 15:44:11 UTC+0100 2015</span><br><span class="line">Fri Jul 03 2015 18:04:07 GMT+0100 (GMT Daylight Time)</span><br><span class="line">September 17, 2012 10:09am</span><br><span class="line">September 17, 2012 at 10:09am PST-08</span><br><span class="line">September 17, 2012, 10:10:09</span><br><span class="line">October 7, 1970</span><br><span class="line">October 7th, 1970</span><br><span class="line">12 Feb 2006, 19:17</span><br><span class="line">12 Feb 2006 19:17</span><br><span class="line">7 oct 70</span><br><span class="line">7 oct 1970</span><br><span class="line">03 February 2013</span><br><span class="line">1 July 2013</span><br><span class="line">2013-Feb-03</span><br><span class="line">3/31/2014</span><br><span class="line">03/31/2014</span><br><span class="line">08/21/71</span><br><span class="line">8/1/71</span><br><span class="line">4/8/2014 22:05</span><br><span class="line">04/08/2014 22:05</span><br><span class="line">4/8/14 22:05</span><br><span class="line">04/2/2014 03:00:51</span><br><span class="line">8/8/1965 12:00:00 AM</span><br><span class="line">8/8/1965 01:00:01 PM</span><br><span class="line">8/8/1965 01:00 PM</span><br><span class="line">8/8/1965 1:00 PM</span><br><span class="line">8/8/1965 12:00 AM</span><br><span class="line">4/02/2014 03:00:51</span><br><span class="line">03/19/2012 10:11:59</span><br><span class="line">03/19/2012 10:11:59.3186369</span><br><span class="line">2014/3/31</span><br><span class="line">2014/03/31</span><br><span class="line">2014/4/8 22:05</span><br><span class="line">2014/04/08 22:05</span><br><span class="line">2014/04/2 03:00:51</span><br><span class="line">2014/4/02 03:00:51</span><br><span class="line">2012/03/19 10:11:59</span><br><span class="line">2012/03/19 10:11:59.3186369</span><br><span class="line">2014年04月08日</span><br><span class="line">2006-01-02T15:04:05+0000</span><br><span class="line">2009-08-12T22:15:09-07:00</span><br><span class="line">2009-08-12T22:15:09</span><br><span class="line">2009-08-12T22:15:09Z</span><br><span class="line">2014-04-26 17:24:37.3186369</span><br><span class="line">2012-08-03 18:31:59.257000000</span><br><span class="line">2014-04-26 17:24:37.123</span><br><span class="line">2013-04-01 22:43</span><br><span class="line">2013-04-01 22:43:22</span><br><span class="line">2014-12-16 06:20:00 UTC</span><br><span class="line">2014-12-16 06:20:00 GMT</span><br><span class="line">2014-04-26 05:24:37 PM</span><br><span class="line">2014-04-26 13:13:43 +0800</span><br><span class="line">2014-04-26 13:13:43 +0800 +08</span><br><span class="line">2014-04-26 13:13:44 +09:00</span><br><span class="line">2012-08-03 18:31:59.257000000 +0000 UTC</span><br><span class="line">2015-09-30 18:48:56.35272715 +0000 UTC</span><br><span class="line">2015-02-18 00:12:00 +0000 GMT</span><br><span class="line">2015-02-18 00:12:00 +0000 UTC</span><br><span class="line">2015-02-08 03:02:00 +0300 MSK m=+0.000000001</span><br><span class="line">2015-02-08 03:02:00.001 +0300 MSK m=+0.000000001</span><br><span class="line">2017-07-19 03:21:51+00:00</span><br><span class="line">2014-04-26</span><br><span class="line">2014-04</span><br><span class="line">2014</span><br><span class="line">2014-05-11 08:20:13,787</span><br><span class="line">3.31.2014</span><br><span class="line">03.31.2014</span><br><span class="line">08.21.71</span><br><span class="line">2014.03</span><br><span class="line">2014.03.30</span><br><span class="line">20140601</span><br><span class="line">20140722105203</span><br><span class="line">1332151919</span><br><span class="line">1384216367189</span><br><span class="line">1384216367111222</span><br><span class="line">1384216367111222333</span><br></pre></td></tr></table></figure>

<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p>本文转载至[<a href="https://sulin.me/2019/38Z4HAT.html]">https://sulin.me/2019/38Z4HAT.html]</a></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Utils</tag>
        <tag>日期解析</tag>
      </tags>
  </entry>
  <entry>
    <title>维护java项目之==和equals</title>
    <url>/2021/03/19/%E7%BB%B4%E6%8A%A4java%E9%A1%B9%E7%9B%AE%E4%B9%8B-%E5%92%8Cequals/</url>
    <content><![CDATA[<p>最近发生一件很尴尬的事情，在维护一个 Java 项目的时候，发现有使用 <code>==</code> 来比较两个对象的属性，<br>于是顺手就把 <code>==</code> 改成了 equals。悲剧发生……</p>
<h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a><code>==</code> 和 equals 的区别</h2><p><code>==</code> ：对于基本类型来说是值比较，对于引用类型来说是引用比较<br>equals：引用比较，但一些类重写了 equals 方法，如 String、Integer 等，变成了值比较。</p>
<h2 id="使用-equals-的前提"><a href="#使用-equals-的前提" class="headerlink" title="使用 equals 的前提"></a>使用 equals 的前提</h2><p>使用 equals 进行比较，如：<br>a 和 b 是两个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.getId().equals(b.getId())</span><br></pre></td></tr></table></figure>

<p>需要确保 a.getId()不为 null，因为 null 是没有.equals()方法的。</p>
<h2 id="各种对象使用-equals"><a href="#各种对象使用-equals" class="headerlink" title="各种对象使用 equals"></a>各种对象使用 equals</h2><p>String 类型：<br>可以使用 StringUtils.equals()进行比较，该方法内置非空校验<br>其余封装类型：<br>可以使用 Objects.equals()进行比较，该方法内置非空校验<br>使用三目运算符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.getId() == <span class="keyword">null</span> ? b.getId() == <span class="keyword">null</span> ? <span class="keyword">false</span> : <span class="keyword">true</span> : a.getId().equals(b.getId())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>equals</tag>
      </tags>
  </entry>
</search>
