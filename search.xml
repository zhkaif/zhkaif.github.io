<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode子矩形查询</title>
    <url>/2021/04/07/LeetCode%E5%AD%90%E7%9F%A9%E5%BD%A2%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="LeetCode-子矩形查询"><a href="#LeetCode-子矩形查询" class="headerlink" title="LeetCode 子矩形查询"></a>LeetCode 子矩形查询</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请你实现一个类<code>SubrectangleQueries</code>，它的构造函数的参数是一个<code>rows * cols</code>的矩形（这里用整数矩阵表示），并支持以下两种操作：</p>
<ol>
<li><code>updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)</code><ul>
<li>用 newValue 更新以<code>(row1,col1)</code>为左上角且以<code>(row2,col2)</code>为右下角的子矩形。</li>
</ul>
</li>
<li><code>getValue(int row, int col)</code><ul>
<li>返回矩形中坐标<code>(row,col)</code>的当前值。</li>
</ul>
</li>
</ol>
<h3 id="一得之见（Java）"><a href="#一得之见（Java）" class="headerlink" title="一得之见（Java）"></a>一得之见（Java）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年4月7日09:37:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubrectangleQueries</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] rect = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubrectangleQueries</span><span class="params">(<span class="keyword">int</span>[][] rectangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rect = rectangle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用 newValue 更新以(row1,col1)为左上角且以(row2,col2)为右下角的子矩形。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row1     子矩形左上角行坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col1     子矩形左上角列坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row2     子矩形右下角行坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col2     子矩形右下角列坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue 子矩形新值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSubrectangle</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rect != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row1; i &lt;= row2; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = col1; j &lt;= col2; j++) &#123;</span><br><span class="line">                    rect[i][j] = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回矩形中坐标(row,col)的当前值。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 行坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 列坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rect != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rect[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="一得之见（Python）"><a href="#一得之见（Python）" class="headerlink" title="一得之见（Python）"></a>一得之见（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubRectangleQueries</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rectangle: List[List[<span class="built_in">int</span>]]</span>):</span></span><br><span class="line">        self.data = rectangle</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_sub_rectangle</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            row1: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            col1: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            row2: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            col2: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            new_value: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        用 newValue 更新以(row1,col1)为左上角且以(row2,col2)为右下角的子矩形。</span></span><br><span class="line"><span class="string">        :param self:</span></span><br><span class="line"><span class="string">        :param row1: 子矩形左上角行坐标</span></span><br><span class="line"><span class="string">        :param col1:子矩形左上角列坐标</span></span><br><span class="line"><span class="string">        :param row2:子矩形右下角行坐标</span></span><br><span class="line"><span class="string">        :param col2:子矩形右下角列坐标</span></span><br><span class="line"><span class="string">        :param new_value:子矩形新值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row1, row2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col1, col2 + <span class="number">1</span>):</span><br><span class="line">                    self.data[i][j] = new_value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_value</span>(<span class="params">self, row, col</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        回矩形中坐标(row,col)的当前值</span></span><br><span class="line"><span class="string">        :param self:</span></span><br><span class="line"><span class="string">        :param row: 行坐标</span></span><br><span class="line"><span class="string">        :param col: 列坐标</span></span><br><span class="line"><span class="string">        :return: 当前值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.data[row][col]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode最富有客户的资产总量</title>
    <url>/2021/04/06/LeetCode%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F/</url>
    <content><![CDATA[<h2 id="最富有客户的资产总量"><a href="#最富有客户的资产总量" class="headerlink" title="最富有客户的资产总量"></a>最富有客户的资产总量</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个 m * n 的整数网格 accounts，其中 account[i][j]是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的资产总量。<br>客户的资产总量就是他们在各家银行托管的资产数量之和。最富有客户就是资产总量最大的客户。</p>
<p>示例 1：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：accounts = [[1,2,3],[3,2,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">第1位客户的资产总量 = 1+2+3=6</span><br><span class="line">第2位客户的资产总量 = 3+2+1=6</span><br><span class="line">两位客户都是最富有的，资产总量都是6，所以返回6。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：accounts = [[1,5],[7,3],[3,5]]</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">第1位客户的资产总量 = 6</span><br><span class="line">第2位客户的资产总量 = 10</span><br><span class="line">第3位客户的资产总量 = 8</span><br><span class="line">第2为客户是最富有的，资产总量是10</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：accounts = [[2,8,7],[7,1,3],[1,9,5]]</span><br><span class="line">输出：17</span><br></pre></td></tr></table></figure>

<h3 id="一得之见（Java）"><a href="#一得之见（Java）" class="headerlink" title="一得之见（Java）"></a>一得之见（Java）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年4月6日11:28:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumWealth</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一个 m * n 的整数网格 accounts，其中 account[i][j]是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的资产总量。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accounts 整数网格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最富有客户的资产总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWealth</span><span class="params">(<span class="keyword">int</span>[][] accounts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> accountsLen = accounts.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; accountsLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; accounts[i].length; j++) &#123;</span><br><span class="line">                sum += accounts[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, sum);</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="他山之石（Java）"><a href="#他山之石（Java）" class="headerlink" title="他山之石（Java）"></a>他山之石（Java）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一个 m * n 的整数网格 accounts，其中 account[i][j]是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的资产总量。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accounts 整数网格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最富有客户的资产总量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWealthTwo</span><span class="params">(<span class="keyword">int</span>[][] accounts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(accounts).map(ints -&gt; Arrays.stream(ints).sum()).max(Integer::compareTo).get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="效率分析（Java）"><a href="#效率分析（Java）" class="headerlink" title="效率分析（Java）"></a>效率分析（Java）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：accounts = &#123;&#123;1,2,3&#125;,&#123;1,4,5&#125;,&#123;1,4,7&#125;&#125;</span><br><span class="line">方法一：2241700ns</span><br><span class="line">方法二：153366300ns</span><br></pre></td></tr></table></figure>

<h3 id="一得之见（Python）"><a href="#一得之见（Python）" class="headerlink" title="一得之见（Python）"></a>一得之见（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_wealth</span>(<span class="params">accounts: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给你一个 m * n 的整数网格 accounts，其中 account[i][j]是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的资产总量。</span></span><br><span class="line"><span class="string">    :param accounts: 整数网格</span></span><br><span class="line"><span class="string">    :return: 最富有客户的资产总量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    accounts_len = <span class="built_in">len</span>(accounts)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(accounts_len):</span><br><span class="line">        len_two = <span class="built_in">len</span>(accounts[i])</span><br><span class="line">        sum_one = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len_two):</span><br><span class="line">            sum_one += accounts[i][j]</span><br><span class="line">            result = <span class="built_in">max</span>(result, sum_one)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="他山之石（Python）"><a href="#他山之石（Python）" class="headerlink" title="他山之石（Python）"></a>他山之石（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_wealth_two</span>(<span class="params">accounts: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给你一个 m * n 的整数网格 accounts，其中 account[i][j]是第 i 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的资产总量。</span></span><br><span class="line"><span class="string">    :param accounts: 整数网格</span></span><br><span class="line"><span class="string">    :return: 最富有客户的资产总量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">sum</span>(accounts[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(accounts)))</span><br></pre></td></tr></table></figure>

<h3 id="效率分析（Python）"><a href="#效率分析（Python）" class="headerlink" title="效率分析（Python）"></a>效率分析（Python）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：accounts = &#123;&#123;1,2,3&#125;,&#123;1,4,5&#125;,&#123;1,4,7&#125;&#125;</span><br><span class="line">方法一：13600ns</span><br><span class="line">方法二：9100ns</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM结构详解</title>
    <url>/2021/03/31/JVM%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="JVM-结构详解"><a href="#JVM-结构详解" class="headerlink" title="JVM 结构详解"></a>JVM 结构详解</h2><h3 id="JVM-结构图"><a href="#JVM-结构图" class="headerlink" title="JVM 结构图"></a>JVM 结构图</h3><p><img src="https://img.imgdb.cn/item/606418cb8322e6675c4307c9.jpg" alt="avatar"></p>
<h4 id="程序计数器（PC-寄存器）"><a href="#程序计数器（PC-寄存器）" class="headerlink" title="程序计数器（PC 寄存器）"></a>程序计数器（PC 寄存器）</h4><h5 id="程序计数器的定义"><a href="#程序计数器的定义" class="headerlink" title="程序计数器的定义"></a>程序计数器的定义</h5><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为 Undefined。</p>
<h5 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h5><ul>
<li>字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制。</li>
<li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li>
</ul>
<h5 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h5><ul>
<li>是一块较小的内存空间。</li>
<li>线程私有，每条线程都有自己的程序计数器。</li>
<li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li>
<li>是唯一一个不会出现 OutOfMemoryError 的内存区域。</li>
</ul>
<h4 id="Java-虚拟机栈（Java-栈）"><a href="#Java-虚拟机栈（Java-栈）" class="headerlink" title="Java 虚拟机栈（Java 栈）"></a>Java 虚拟机栈（Java 栈）</h4><h5 id="Java-虚拟机栈的定义"><a href="#Java-虚拟机栈的定义" class="headerlink" title="Java 虚拟机栈的定义"></a>Java 虚拟机栈的定义</h5><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p>
<p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做<code>栈帧</code>的区域，用于存放该方法运行过程中的一些信息，如：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口信息</li>
<li>……</li>
</ul>
<h5 id="压栈出栈过程"><a href="#压栈出栈过程" class="headerlink" title="压栈出栈过程"></a>压栈出栈过程</h5><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p>
<p>Java 虚拟机栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p>
<p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p>
<p>由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</p>
<h5 id="Java-虚拟机栈的特点"><a href="#Java-虚拟机栈的特点" class="headerlink" title="Java 虚拟机栈的特点"></a>Java 虚拟机栈的特点</h5><ul>
<li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可，在方法运行过程中，局部变量表的大小不会发生改变。</li>
<li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul>
<li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态拓展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li>
<li>OutOfMemoryError 若允许动态拓展，那么当线程请求栈时内存用完了，无法再动态拓展时，抛出 OutOfMemoryError 异常。</li>
</ul>
</li>
<li>Java 虚拟机栈是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li>
</ul>
<p>出现 StackOverFlowError 时，内存空间可能还有很多。</p>
<h4 id="本地方法栈（c-栈）"><a href="#本地方法栈（c-栈）" class="headerlink" title="本地方法栈（c 栈）"></a>本地方法栈（c 栈）</h4><h5 id="本地方法栈的定义"><a href="#本地方法栈的定义" class="headerlink" title="本地方法栈的定义"></a>本地方法栈的定义</h5><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>
<h5 id="栈帧变化过程"><a href="#栈帧变化过程" class="headerlink" title="栈帧变化过程"></a>栈帧变化过程</h5><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、方法出口信息等。</p>
<p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMeMoryError 异常。</p>
<p>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h5 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h5><p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。</p>
<h5 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h5><ul>
<li>线程共享，整个 Java 虚拟机只有一个堆，所有线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li>
<li>在虚拟机启动时创建。</li>
<li>是垃圾回收的主要场所。</li>
<li>进一步可分为：新生代（Eden 区：<code>From Survior</code>，<code>To Survior</code>、老年代。</li>
</ul>
<p>不同区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p>
<p>堆的大小既可以固定也可以拓展，但对于主流的虚拟机，堆的大小是可拓展的，因此当线程请求分配内存，但堆已满，且内存已无法再拓展时，会抛出 OutOfMemoryError 异常。</p>
<p>Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><h5 id="方法区的定义"><a href="#方法区的定义" class="headerlink" title="方法区的定义"></a>方法区的定义</h5><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放一下信息：</p>
<ul>
<li>已经被虚拟机加载的类信息</li>
<li>常量</li>
<li>静态变量</li>
<li>即时编译器编译后的代码</li>
</ul>
<h5 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h5><ul>
<li>线程共享。方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享。整个虚拟机中只有一个方法区。</li>
<li>永久代。方法区中的信息一般需要长期存在，而且它又是堆的逻辑部分，因此用堆的划分方法，把方法区成为<code>永久代</code>。</li>
<li>内存回收效率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li>
<li>Java 虚拟机规范对方法区的要求比较宽松。和堆一样，允许固定大小，也允许动态拓展，还允许不实现垃圾回收。</li>
</ul>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>方法区中存放：类信息、常量、静态变量、及时编译器编译后的代码。常量就存放在运行时常量池中。</p>
<p>当类被 Java 虚拟机加载后，.class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的<code>intern()</code>方法就能在运行期间向常量池中添加字符串常量。</p>
<h4 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h4><p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p>
<h5 id="操作直接内存"><a href="#操作直接内存" class="headerlink" title="操作直接内存"></a>操作直接内存</h5><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提供了数据操作的效率。</p>
<p>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</p>
<h5 id="直接内存和堆内存比较"><a href="#直接内存和堆内存比较" class="headerlink" title="直接内存和堆内存比较"></a>直接内存和堆内存比较</h5><ul>
<li>直接内存申请空间耗费更高的性能</li>
<li>直接内存读取 IO 的性能要优于普通的堆内存</li>
<li>直接内存作用链：本地 IO -&gt; 直接内存 -&gt; 本地 IO</li>
<li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li>
</ul>
<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域综合大于物理内存限制，从而导致动态拓展时出现<code>OutOfMemoryError</code>异常。</p>
<h3 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h3><p><a href="https://doocs.github.io/jvm/#/docs/01-jvm-memory-structure">https://doocs.github.io/jvm/#/docs/01-jvm-memory-structure</a></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode一维数组的动态和</title>
    <url>/2021/03/31/LeetCode%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</url>
    <content><![CDATA[<h2 id="一维数组的动态和"><a href="#一维数组的动态和" class="headerlink" title="一维数组的动态和"></a>一维数组的动态和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 nums。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i])。<br>请返回 nums 的动态和。</p>
<p>示例 1：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,2,10,1]</span><br><span class="line">输出：[3,4,5,16,17]</span><br><span class="line">解释：动态和计算过程为 [3, 3+1, 3+1+5, 3+1+5+10, 3+1+5+10+1]</span><br></pre></td></tr></table></figure>

<h3 id="一得之见（Java）"><a href="#一得之见（Java）" class="headerlink" title="一得之见（Java）"></a>一得之见（Java）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年3月31日10:07:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningSum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</span></span><br><span class="line"><span class="comment">     * 请返回 nums 的动态和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> nums 的动态和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] runningSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> numsLen = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (numsLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[numsLen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                result[i] += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="他山之石（Java）"><a href="#他山之石（Java）" class="headerlink" title="他山之石（Java）"></a>他山之石（Java）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</span></span><br><span class="line"><span class="comment">    * 请返回 nums 的动态和</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> nums 的动态和</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] runningSumTwo(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; i++ )&#123;</span><br><span class="line">           nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</span></span><br><span class="line"><span class="comment">     * 请返回 nums 的动态和</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> nums 的动态和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] runningSumThree(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> numsLen = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[numsLen];</span><br><span class="line">        result[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLen; i++) &#123;</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="效率分析-Java"><a href="#效率分析-Java" class="headerlink" title="效率分析(Java)"></a>效率分析(Java)</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">方法一用时：1820300ns</span><br><span class="line">方法二用时：8600ns</span><br><span class="line">方法三用时：11300ns</span><br></pre></td></tr></table></figure>

<h3 id="一得之见（Python）"><a href="#一得之见（Python）" class="headerlink" title="一得之见（Python）"></a>一得之见（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">running_sum</span>(<span class="params">nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</span></span><br><span class="line"><span class="string">    请返回 nums 的动态和</span></span><br><span class="line"><span class="string">    :param nums: 数组</span></span><br><span class="line"><span class="string">    :return: 数组的动态和</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    nums_len = <span class="built_in">len</span>(nums)</span><br><span class="line">    result = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums_len)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums_len):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>):</span><br><span class="line">            result[i] += nums[j]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="他山之石（Python）"><a href="#他山之石（Python）" class="headerlink" title="他山之石（Python）"></a>他山之石（Python）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">running_sum_two</span>(<span class="params">nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</span></span><br><span class="line"><span class="string">    请返回 nums 的动态和</span></span><br><span class="line"><span class="string">    :param nums: 数组</span></span><br><span class="line"><span class="string">    :return: 数组的动态和</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    nums_len = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = [nums[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nums_len):</span><br><span class="line">        total = res[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        res.append(total)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="效率分析-Python"><a href="#效率分析-Python" class="headerlink" title="效率分析(Python)"></a>效率分析(Python)</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">方法一用时：15700ns</span><br><span class="line">方法二用时：6500ns</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java交换数组元素</title>
    <url>/2021/03/30/Java%E4%BA%A4%E6%8D%A2%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="Java-交换数组元素"><a href="#Java-交换数组元素" class="headerlink" title="Java 交换数组元素"></a>Java 交换数组元素</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年3月30日14:09:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwapElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组下标为i和数组下标为j的两个数组元素进行交换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待交换数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    需交换下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j    需交换下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 交换后的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] swapElementOne(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = item;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组下标为i和数组下标为j的两个数组元素进行交换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待交换数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    需交换下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j    需交换下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 交换后的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] swapElementTwo(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        List&lt;Integer&gt; item = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line">        Collections.swap(item, i, j);</span><br><span class="line">        <span class="keyword">int</span>[] result = item.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组下标为i和数组下标为j的两个数组元素进行交换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待交换数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    需交换下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j    需交换下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 交换后的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] swapElementThree(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        nums[i] ^= nums[j];</span><br><span class="line">        nums[j] ^= nums[i];</span><br><span class="line">        nums[i] ^= nums[j];</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 2, 3, 4&#125;; i=1; j=3;</span><br><span class="line">方法一：2420500ns</span><br><span class="line">方法二：163113800ns</span><br><span class="line">方法三：20200ns</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>方法一：<br>  使用中间变量进行交换，不能直接进行交换。</li>
<li>方法二：<br>  使用Collections.swap()方法进行交换，需要先将数组转换成List，交换完成后再转换成数组返回。</li>
<li>方法三：<br>  使用位运算符进行交换。<br>  ^：如果相对应位值相同，则结果为0，否则为1<br>  <code>C ^= C1 等价于 C = C^C1</code></li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode缺失的第一个正数</title>
    <url>/2021/03/29/LeetCode%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h2 id="LeetCode-缺失的第一个正数"><a href="#LeetCode-缺失的第一个正数" class="headerlink" title="LeetCode 缺失的第一个正数"></a>LeetCode 缺失的第一个正数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数。</p>
<p>进阶：你可以实现时间复杂度为 O(n)并且只使用常数级别额外空间的解决方案吗？</p>
<p>示例 1：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h3 id="Java-解法"><a href="#Java-解法" class="headerlink" title="Java 解法"></a>Java 解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年3月29日13:51:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstMissingPositive</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 未排序的整数数组 nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 没有出现的最小的正整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLen = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (numsLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numsLen + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> resLen = res.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt; resLen) &#123;</span><br><span class="line">                res[x] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; resLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != res[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 未排序的整数数组 nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 没有出现的最小的正整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstMissingPositiveTwo</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLen = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (numsLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLen; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; numsLen + <span class="number">1</span> &amp;&amp; nums[i] != i + <span class="number">1</span> &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numsLen + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组元素位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 未排序的整数数组 nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 需交换元素数组index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 与需交换元素进行交换的数组index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">            nums[j] ^= nums[j];</span><br><span class="line">            nums[j] ^= nums[i];</span><br><span class="line">            nums[i] ^= nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Java-解法效率对比"><a href="#Java-解法效率对比" class="headerlink" title="Java 解法效率对比"></a>Java 解法效率对比</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 3, 6, 7, 9&#125;;</span><br><span class="line">方法一：2708900ns</span><br><span class="line">方法二：15400ns</span><br></pre></td></tr></table></figure>

<h3 id="Python-解法"><a href="#Python-解法" class="headerlink" title="Python 解法"></a>Python 解法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_missing_positive</span>(<span class="params">nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数</span></span><br><span class="line"><span class="string">    :param nums: 未排序的整数数组</span></span><br><span class="line"><span class="string">    :return: 没有出现的最小的正整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; x &lt; <span class="built_in">len</span>(res):</span><br><span class="line">            res[x] = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">        <span class="keyword">if</span> res[i] != i:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_missing_positive_two</span>(<span class="params">nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数</span></span><br><span class="line"><span class="string">    :param nums: 未排序的整数数组</span></span><br><span class="line"><span class="string">    :return: 没有出现的最小的正整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; nums[i] &lt; n + <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">1</span>] != i + \</span><br><span class="line">                <span class="number">1</span> <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">            swap(nums, i, nums[i] - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">nums: List[<span class="built_in">int</span>], i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> i != j:</span><br><span class="line">        nums[i] ^= nums[j]</span><br><span class="line">        nums[j] ^= nums[i]</span><br><span class="line">        nums[i] ^= nums[j]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Python-解法效率对比"><a href="#Python-解法效率对比" class="headerlink" title="Python 解法效率对比"></a>Python 解法效率对比</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 3, 6, 7, 9&#125;;</span><br><span class="line">方法一：13900ns</span><br><span class="line">方法二：17100ns</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch的倒排索引</title>
    <url>/2021/03/25/Elasticsearch%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode移除元素</title>
    <url>/2021/03/25/LeetCode%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="LeetCode-移除元素"><a href="#LeetCode-移除元素" class="headerlink" title="LeetCode 移除元素"></a>LeetCode 移除元素</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不需要使用额外的数组空间，你必须仅使用 O(1)额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h3 id="Java-解法"><a href="#Java-解法" class="headerlink" title="Java 解法"></a>Java 解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment">     * 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="comment">     * 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val  判断值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment">     * 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="comment">     * 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val  判断值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElementTwo</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == val) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-解法效率对比"><a href="#Java-解法效率对比" class="headerlink" title="Java 解法效率对比"></a>Java 解法效率对比</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;val = 2;</span><br><span class="line">方法一：2666500ns</span><br><span class="line">方法二：15300ns</span><br></pre></td></tr></table></figure>

<h3 id="Python-解法"><a href="#Python-解法" class="headerlink" title="Python 解法"></a>Python 解法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_element</span>(<span class="params">nums: List[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="string">    不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="string">    元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="string">    :param nums: 数组</span></span><br><span class="line"><span class="string">    :param val: 判断值</span></span><br><span class="line"><span class="string">    :return: 新数组的长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == val:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_element_two</span>(<span class="params">nums: List[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="string">    不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="string">    元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"><span class="string">    :param nums: 数组</span></span><br><span class="line"><span class="string">    :param val: 判断值</span></span><br><span class="line"><span class="string">    :return: 新数组的长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> nums[j] == val:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Python-解法效率对比"><a href="#Python-解法效率对比" class="headerlink" title="Python 解法效率对比"></a>Python 解法效率对比</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;val = 2;</span><br><span class="line">方法一：60700ns</span><br><span class="line">方法二：36200ns</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode两数之和</title>
    <url>/2021/03/23/LeetCode%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="LeetCode-两数之和"><a href="#LeetCode-两数之和" class="headerlink" title="LeetCode 两数之和"></a>LeetCode 两数之和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">给定nums = [2,7,11,15],target=9</span><br><span class="line">因为nums[0] + nums[1] = 2 + 7 = 9 所以返回[0, 1]</span><br></pre></td></tr></table></figure>

<h3 id="Java-解法"><a href="#Java-解法" class="headerlink" title="Java 解法"></a>Java 解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年3月23日14:27:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoNumSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_NUMS = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums   整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组中和为目标值的两个整数的数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoNumSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; NUM_NUMS) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums   整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组中和为目标值的两个整数的数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoNumSumMap(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Java解法效率对比"><a href="#Java解法效率对比" class="headerlink" title="Java解法效率对比"></a>Java解法效率对比</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 3, 5, 7, 9, 12, 13, 19, 20&#125;;target = 23;</span><br><span class="line">方法一：5074400ns</span><br><span class="line">方法二：264300ns</span><br></pre></td></tr></table></figure>

<h3 id="Python-解法"><a href="#Python-解法" class="headerlink" title="Python 解法"></a>Python 解法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_dict</span>(<span class="params">nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标</span></span><br><span class="line"><span class="string">   :param nums: 整数数组</span></span><br><span class="line"><span class="string">   :param target: 目标值</span></span><br><span class="line"><span class="string">   :return: 数组中和为目标值的两个整数的数组下标</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">    dict_item = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> target - num <span class="keyword">in</span> dict_item:</span><br><span class="line">            <span class="keyword">return</span> [dict_item[target - num], i]</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span>(<span class="params">nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标</span></span><br><span class="line"><span class="string">    :param nums: 整数数组</span></span><br><span class="line"><span class="string">    :param target: 目标值</span></span><br><span class="line"><span class="string">    :return: 数组中和为目标值的两个整数的数组下标</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                <span class="keyword">return</span> [i, j]</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Python解法效率对比"><a href="#Python解法效率对比" class="headerlink" title="Python解法效率对比"></a>Python解法效率对比</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：nums = &#123;1, 3, 5, 7, 9, 12, 13, 19, 20&#125;;target = 23;</span><br><span class="line">方法一：10200ns</span><br><span class="line">方法二：6800ns</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch入门</title>
    <url>/2021/03/23/Elasticsearch%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h2><p>Elasticsearch 是一款分布式搜索和分析引擎，为所有类型的数据提供快速近乎于实时的搜索和分析。无论是结构化文本还是非结构化文本，数字数据或地理空间数据，Elasticsearch 都能快速有效的对其进行存储和索引。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>应用或者网站的搜索框</li>
<li>存储和分析日志、指标和安全事件数据</li>
<li>机器学习用来实时自动模拟数据行为</li>
<li>作为存储引擎，实现业务工作流的自动化</li>
<li>作为地理信息系统（GIS）来管理、整合和分析空间信息</li>
<li>作为生物信息学研究工具存储和处理遗传数据</li>
</ul>
<h3 id="数据存储：文档和索引"><a href="#数据存储：文档和索引" class="headerlink" title="数据存储：文档和索引"></a>数据存储：文档和索引</h3><p>Elasticsearch 不会将信息存储为列数据的行，而是存储已序列化为 JSON 文档的复杂数据结构。索引可以看做是文档的优化集合，每个文档都是字段的集合，这些字段包含数据的键值对。</p>
<p>Elasticsearch 为每个字段中的所有数据建立索引，并且每个索引字段都具有专门的优化数据结构。例如，文本字段存储在倒排索引中，数字字典和地理字段存储在 BKD 树中。</p>
<h2 id="Elasticsearch-安装"><a href="#Elasticsearch-安装" class="headerlink" title="Elasticsearch 安装"></a>Elasticsearch 安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载链接 <a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>直接将下载的压缩包解压，启动<code>bin</code>目录下面的<code>elasticsearch.bat</code></p>
<p>浏览器打开<a href="http://localhost:9200/">http://localhost:9200/</a>查看 Elasticsearch 服务信息</p>
<p><img src="https://img.imgdb.cn/item/6061419f8322e6675c770dcf.jpg" alt="avatar"></p>
<h3 id="配置远程访问"><a href="#配置远程访问" class="headerlink" title="配置远程访问"></a>配置远程访问</h3><p>打开<code>config</code>目录下的<code>elasticsearch.yml</code>配置文件</p>
<p><code>修改network.host: 你的IP地址</code></p>
<p>放开注释<code>#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;]</code><br>节点根据情况进行增删</p>
]]></content>
      <categories>
        <category>DB</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>BIO/NIO/AIO对比</title>
    <url>/2021/03/22/BIO-NIO-AIO%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h2><p>就是使用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。<br>Java 支持三种网络编程模型：BIO、NIO、AIO。</p>
<ul>
<li><p>Java BIO，同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善。</p>
</li>
<li><p>Java NIO，同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求会被注册到多路复用器上，多路复用器轮询到有 IO 请求就会进行处理。</p>
</li>
<li><p>Java AIO，异步非阻塞，AIO 引入了异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p>
</li>
</ul>
<h2 id="BIO、NIO、AIO-使用场景"><a href="#BIO、NIO、AIO-使用场景" class="headerlink" title="BIO、NIO、AIO 使用场景"></a>BIO、NIO、AIO 使用场景</h2><ul>
<li>BIO 方式适用于连接数比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 之前唯一的选择，程序较为简单容易理解。</li>
<li>NIO 方式适用于连接数目多且连接比较短的架构，比如聊天服务器，弹幕系统，服务器间通讯等，编程比较复杂，JDK1.4 开始支持。</li>
<li>AIO 方式适用于连接数目多且连接比较长的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</li>
</ul>
<h2 id="BIO-基本介绍"><a href="#BIO-基本介绍" class="headerlink" title="BIO 基本介绍"></a>BIO 基本介绍</h2><ul>
<li>Java BIO 就是传统的 Java IO 编程，其相关的类和接口在 java.io 包下。</li>
<li>BIO（Blocking I/O）：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器就会需要启动一个线程来进行处理。如果这个连接不做任何事情就会造成不必要的线程开销，可以通过线程池机制改善。</li>
</ul>
<h3 id="BIO-编程简要流程"><a href="#BIO-编程简要流程" class="headerlink" title="BIO 编程简要流程"></a>BIO 编程简要流程</h3><ol>
<li>服务器驱动一个 ServiceSocket。</li>
<li>客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每一个客户端建立一个线程进行通信。</li>
<li>客户端发出请求后，先咨询服务器是否线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
<h3 id="BIO-服务端代码案例"><a href="#BIO-服务端代码案例" class="headerlink" title="BIO 服务端代码案例"></a>BIO 服务端代码案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年3月22日14:35:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bio</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BIO 测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bioTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 创建serverSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接中...&quot;</span>);</span><br><span class="line">            <span class="comment">// 监听，等待客户端连接</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            executorService.execute(() -&gt; handler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个handler方法，和客户端通讯</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socket 套接字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程信息：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">// 循环读取客户度发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (inputStream.read(bytes) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：发送信息为：&quot;</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, bytes.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>启动该案例</li>
<li>使用终端命令<code>telnet 127.0.0.1 6666</code>，打开 telnet 命令窗口<br><img src="https://img.imgdb.cn/item/60582d968322e6675c66aa1d.jpg" alt="avatar"></li>
<li>按下<code>ctrl+]</code><br><img src="https://img.imgdb.cn/item/60582da28322e6675c66b0b1.jpg" alt="avatar"></li>
<li>输入<code>send hello world</code>，进行通信<br><img src="https://img.imgdb.cn/item/60582da98322e6675c66b3ca.jpg" alt="avatar"></li>
<li>输入<code>quit</code>退出 telnet 窗口，关闭连接<br><img src="https://img.imgdb.cn/item/60582daf8322e6675c66b674.jpg" alt="avatar"></li>
</ul>
<h3 id="BIO-问题分析"><a href="#BIO-问题分析" class="headerlink" title="BIO 问题分析"></a>BIO 问题分析</h3><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据处理。</li>
<li>当并发数大时，需要创建大量线程来处理连接，系统资源占用大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则当前线程会一直阻塞在 Read 操作上，造成线程资源浪费。</li>
</ol>
<h2 id="NIO-基本介绍"><a href="#NIO-基本介绍" class="headerlink" title="NIO 基本介绍"></a>NIO 基本介绍</h2><ol>
<li>Java NIO 全称 Java non-blocking IO，指的是 JDK 提供新的 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO，即 New IO，是同步非阻塞的。</li>
<li>NIO 相关类都放在 java.io 包下，并对原 java.io 包中很多类进行了改写。</li>
<li>NIO 有三大核心部分：Channel（管道）、Buffer（缓冲区）、Selector（选择器）。</li>
<li>NIO 是面向缓冲区编程的，数据读取到一个它稍微处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程的灵活性，使用它可以提供非阻塞的高伸缩性网格。</li>
<li>Java NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用数据，如果目前没有可用数据时，则说明都不会获取，而不是保持线程阻塞，所以直到数据变为可以读取之前，该线程可以做其他事情。非阻塞写入同理。</li>
</ol>
<h3 id="NIO-Buffer-的基本使用"><a href="#NIO-Buffer-的基本使用" class="headerlink" title="NIO Buffer 的基本使用"></a>NIO Buffer 的基本使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年3月22日14:39:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nio</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NIO 测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nioTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//同理对应的还有：ByteBuffer,IntBuffer,FloatBuffer,CharBuffer,ShortBuffer,DoubleBuffer,LongBuffer</span></span><br><span class="line">        <span class="comment">//创建一个Buffer，大小为5</span></span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 存放数据</span></span><br><span class="line">        <span class="keyword">int</span> size = buffer.capacity();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            buffer.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切换成读模式，读写切换</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NIO-三大核心组件关系"><a href="#NIO-三大核心组件关系" class="headerlink" title="NIO 三大核心组件关系"></a>NIO 三大核心组件关系</h3><p><img src="https://img.imgdb.cn/item/60583dcf8322e6675c703e73.png" alt="avatar"></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>每个 Channel 对应一个 Buffer。</li>
<li>Selector 对应一个线程，一个线程对应多个 Channel。</li>
<li>该图反应了有三个 Channel 注册到该 Selector。</li>
<li>该程序切换到哪个 Channel 是由事件决定的（Event）。</li>
<li>Selector 会根据不同的事件，在各个通道上切换。</li>
<li>Buffer 就是一个内存块，底层是一个数组。</li>
<li>数据的读取和写入是通过 Buffer，但是需要 flip()切换读写模式。而 BIO</li>
</ol>
<h3 id="NIO-三大核心理解"><a href="#NIO-三大核心理解" class="headerlink" title="NIO 三大核心理解"></a>NIO 三大核心理解</h3><p><img src="https://img.imgdb.cn/item/605844f48322e6675c747b0b.jpg" alt="avatar"></p>
<h4 id="Buffer-的机制及子类"><a href="#Buffer-的机制及子类" class="headerlink" title="Buffer 的机制及子类"></a>Buffer 的机制及子类</h4><h5 id="Buffer（缓冲区）基本介绍"><a href="#Buffer（缓冲区）基本介绍" class="headerlink" title="Buffer（缓冲区）基本介绍"></a>Buffer（缓冲区）基本介绍</h5><p>缓冲区本质上是一个可以读写数据的内存块，可以理解为是一个容器对象（含数组），该对象提供了一组方法，可以更轻松的使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<br>Channel 提供从文件、网络读取数据的渠道，但是读取或者写都必须经过 Buffer。<br>在 Buffer 子类中维护着一个对应类型的数组，用来存放数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Buffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">IntBuffer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These fields are declared here rather than in Heap-X-Buffer in order to</span></span><br><span class="line">    <span class="comment">// reduce the number of virtual method invocations needed to access these</span></span><br><span class="line">    <span class="comment">// values, which is especially costly when coding small buffers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">boolean</span> isReadOnly;                 <span class="comment">// Valid only for heap buffers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates a new buffer with the given mark, position, limit, capacity,</span></span><br><span class="line">    <span class="comment">// backing array, and array offset</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    IntBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   <span class="comment">// package-private</span></span><br><span class="line">                 <span class="keyword">int</span>[] hb, <span class="keyword">int</span> offset)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">        <span class="keyword">this</span>.hb = hb;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates a new buffer with the given mark, position, limit, and capacity</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    IntBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123; <span class="comment">// package-private</span></span><br><span class="line">        <span class="keyword">this</span>(mark, pos, lim, cap, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Buffer 常用子类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ByteBuffer</td>
<td>存储字节数据到缓冲区</td>
</tr>
<tr>
<td>ShortBuffer</td>
<td>存储字符创数据到缓冲区</td>
</tr>
<tr>
<td>CharBuffer</td>
<td>存储字符数据到缓冲区</td>
</tr>
<tr>
<td>IntBuffer</td>
<td>存储整数数据到缓冲区</td>
</tr>
<tr>
<td>LongBuffer</td>
<td>存储长整型数据到缓冲区</td>
</tr>
<tr>
<td>DoubleBuffer</td>
<td>存储浮点型数据到缓冲区</td>
</tr>
<tr>
<td>FloatBuffer</td>
<td>存储浮点型数据到缓冲区</td>
</tr>
</tbody></table>
<p>Buffer 中定义了四个属性来提供所有其包含的数据元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>容量，即可以容纳的最大数据量；在缓冲区被创建时就被指定，无法修改</td>
</tr>
<tr>
<td>limit</td>
<td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作，但极限是可以修改的</td>
</tr>
<tr>
<td>position</td>
<td>当前位置，下一个要被读或者写的索引，每次读写缓冲区数据都会改变该值，为下次读写做准备</td>
</tr>
<tr>
<td>Mark</td>
<td>标记当前 position 位置，当 reset 后回到标记位置</td>
</tr>
</tbody></table>
<h4 id="Channel-的基本介绍"><a href="#Channel-的基本介绍" class="headerlink" title="Channel 的基本介绍"></a>Channel 的基本介绍</h4><p>NIO 的通道类似于流，但有如下区别：</p>
<ol>
<li>通道是双向的可以进行读写，而流是单向的只能读，或者写。</li>
<li>通道可以实现已读读取数据。</li>
<li>通道可以从缓冲区读取数据，也可以写入数据到缓冲区。</li>
</ol>
<p>常用的 Channel 有：FileChannel、DatagramChannel、SocketChannel、SocketServerChannel</p>
<h5 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h5><p>FileChannel 主要用来对本地文件进行 IO 操作，常见的方法有：</p>
<ol>
<li><p>使用 FileChannel 写入文本文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用FileChannel写入文本文件</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nioFileChannelWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     String writeStr = <span class="string">&quot;Hello, Java菜鸟程序员&quot;</span>;</span><br><span class="line">     <span class="comment">// 创建一个输出流</span></span><br><span class="line">     FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">     <span class="comment">// 获取通道</span></span><br><span class="line">     FileChannel channel = fileOutputStream.getChannel();</span><br><span class="line">     <span class="comment">// 创建缓冲区</span></span><br><span class="line">     ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">     <span class="comment">// 写入byteBuffer</span></span><br><span class="line">     byteBuffer.put(writeStr.getBytes());</span><br><span class="line">     <span class="comment">// 切换模式</span></span><br><span class="line">     byteBuffer.flip();</span><br><span class="line">     <span class="comment">// 写入通道</span></span><br><span class="line">     channel.write(byteBuffer);</span><br><span class="line">     <span class="comment">// 关闭</span></span><br><span class="line">     channel.close();</span><br><span class="line">     fileOutputStream.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 FileChannel 读取文本文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用FileChannel 读取文本文件</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nioFileChannelRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">     FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">     FileChannel channel = fileInputStream.getChannel();</span><br><span class="line">     ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">     channel.read(byteBuffer);</span><br><span class="line">     System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, byteBuffer.limit()));</span><br><span class="line">     channel.close();</span><br><span class="line">     fileInputStream.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 FileChannel 复制文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用FileChannel复制文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nioFileChannelCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;world.txt&quot;</span>);</span><br><span class="line">    FileChannel inChannel = fileInputStream.getChannel();</span><br><span class="line">    FileChannel outChannel = fileOutputStream.getChannel();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(byteBuffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        outChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">// 清空重置</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 transferFrom 复制文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用transferFrom复制文件</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nioTransferFromCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">     FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">     FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;world.txt&quot;</span>);</span><br><span class="line">     FileChannel inChannel = fileInputStream.getChannel();</span><br><span class="line">     FileChannel outChannel = fileOutputStream.getChannel();</span><br><span class="line">     <span class="comment">// 从哪拷贝，从几开始到几结束 对应的还有transferTo()方法</span></span><br><span class="line">     outChannel.transferFrom(inChannel, <span class="number">0</span>, inChannel.size());</span><br><span class="line">     outChannel.close();</span><br><span class="line">     fileOutputStream.close();</span><br><span class="line">     fileInputStream.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="Channel-和-Buffer-的注意事项"><a href="#Channel-和-Buffer-的注意事项" class="headerlink" title="Channel 和 Buffer 的注意事项"></a>Channel 和 Buffer 的注意事项</h5><ol>
<li>ByteBuffer 支持类型化的 put 和 get，put 放入什么数据类型，get 就应该使用相应的数据类型来取出，否则可能会产生 ByteUnderflowException 异常。</li>
<li>可以将一个普通的 Buffer 转换为只读的 Buffer：asReadOnlyBuffer()方法。</li>
<li>NIO 提供了 MapperByteBuffer，可以让文件直接在内存（堆外内存）中进行修改，而如何同步到文件由 NIO 来完成。</li>
<li>NIO 还支持通过多个 Buffer（即 Buffer 数组）完成读写操作，即 Scattering（分散）和 Gathering（聚集）。<ul>
<li>Scattering（分散）：在向缓冲区写入数据时，可以使用 Buffer 数组一次写入，一个 Buffer 数组写满后，继续写入下一个 Buffer 数组。</li>
<li>Gatering（聚集）：从缓冲区读取数据时，可以依次读取，读完一个 Buffer 再按顺序读取一下个。</li>
</ul>
</li>
</ol>
<h4 id="Selector-的基本介绍"><a href="#Selector-的基本介绍" class="headerlink" title="Selector 的基本介绍"></a>Selector 的基本介绍</h4><ol>
<li>Java 的 NIO 使用了非阻塞的 I/O 方式。可以用一个线程处理若干个客户端连接，就会使用到 Selector（选择器）。</li>
<li>Selector 能够检测到多个注册通道上是否有事件发生（多个 Channel 以事件的形式注册到同一个 selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。</li>
<li>只有在连接真正有读写事件发生时，才会进行读写，减少系统开销，并且不必为每个连接都创建一个线程，不用维护多个线程。</li>
<li>避免了多线程之间上下文切换导致的开销。</li>
</ol>
<h5 id="Selector-特点"><a href="#Selector-特点" class="headerlink" title="Selector 特点"></a>Selector 特点</h5><p>Netty 的 I/O 线程 NioEventLoop 聚合了 Selector（选择器/多路复用器），可以并发处理成百上千个客户端连接。</p>
<p>当线程从某个客户端 Socket 通道进行读写时，若没有数据可用，该线程可以进行其他任务。</p>
<p>线程通常将非阻塞 I/O 的空闲时间用于其他通道上执行 I/O 操作，所以单独的线程可以管理多个输入输出通道。</p>
<p>由于读写操作都是非阻塞的，就可以充分提高 I/O 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。</p>
<p>一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本解决了传统同步阻塞 I/O 一连接一线程模型，架构性能、弹性伸缩能力和可靠性都得到极大的提升。</p>
<h5 id="Selector-常用方法"><a href="#Selector-常用方法" class="headerlink" title="Selector 常用方法"></a>Selector 常用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span> <span class="title">implement</span> <span class="title">Closeable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 得到一个选择器对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>; <span class="comment">// 监听所有注册的通道，当其中的IO操作可以进行时，将对应的selectionkey加入内部集合并返回，参数设置超时时间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">selectionKeys</span><span class="params">()</span></span>; <span class="comment">// 从内部集合中得到所有的SelectionKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Selector-相关方法说明"><a href="#Selector-相关方法说明" class="headerlink" title="Selector 相关方法说明"></a>Selector 相关方法说明</h5><ul>
<li>selector.select()：若监听到注册管道中有事件，则持续阻塞</li>
<li>selector.select(1000)：阻塞 1000 毫秒，1000 毫秒后返回</li>
<li>selector.wakeup()：换线 selector</li>
<li>selector.selectNow()：不阻塞，立即返回</li>
</ul>
<h4 id="NIO-非阻塞网络编程过程分析"><a href="#NIO-非阻塞网络编程过程分析" class="headerlink" title="NIO 非阻塞网络编程过程分析"></a>NIO 非阻塞网络编程过程分析</h4><ol>
<li>当客户端连接时，会通过 SeverSocketChannel 得到对应的 SocketChannel。</li>
<li>Selector 进行监听，调用 select()方法，返回注册该 selector 的所有通道中有事件发生的通道个数。</li>
<li>将 socketChannel 注册到 Selector 上，<code>public final SelectionKey register(Selector sel, int ops)</code>，一个 selector 上可以注册多个 SocketChannel。</li>
<li>注册后返回一个 SelectionKey，会和该 Selector 关联（以集合的形式）。</li>
<li>进一步得到各个 SelectionKey，有事件发生。</li>
<li>再通过 SelectionKey 反向获取 SocketChannel，使用 channel()方法。</li>
<li>可以通过得到的 channel，完成业务处理。</li>
</ol>
<p>SelectionKey 中定义了四个操作标志位：OP_READ 表示通道中发生读事件；OP_WRITE 表示通道中发生写事件；OP_CONNECT 表示建立连接；OP_ACCEPT 表示请求连接。</p>
<h5 id="SelectionKey-相关方法"><a href="#SelectionKey-相关方法" class="headerlink" title="SelectionKey 相关方法"></a>SelectionKey 相关方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract Selector selector();</td>
<td>得到与之关联的 Selector 对象</td>
</tr>
<tr>
<td>public abstract SelectableChannel channel();</td>
<td>得到与之关联的通道</td>
</tr>
<tr>
<td>public final Object attachment();</td>
<td>得到与之关联的共享数据</td>
</tr>
<tr>
<td>public abstract SelectionKey interestOps(int ops);</td>
<td>设置或改变监听的事件类型</td>
</tr>
<tr>
<td>public final boolean isReadable();</td>
<td>通道是否可读</td>
</tr>
<tr>
<td>public final boolean usWritable();</td>
<td>通道是否可写</td>
</tr>
<tr>
<td>public final boolean isAcceptable();</td>
<td>是否可以建立连接 ACCEPT</td>
</tr>
</tbody></table>
<h3 id="NIO-和-BIO-对比"><a href="#NIO-和-BIO-对比" class="headerlink" title="NIO 和 BIO 对比"></a>NIO 和 BIO 对比</h3><ol>
<li>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比 I/O 高很多。</li>
<li>BIO 是阻塞的，而 NIO 是非阻塞的。</li>
<li>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区中写入到通道中。Selector（选择器）用于监听多个通道事件（比如连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
</ol>
<h3 id="AIO-基本介绍"><a href="#AIO-基本介绍" class="headerlink" title="AIO 基本介绍"></a>AIO 基本介绍</h3><p>JDK7 引入了 ASynchronous I/O，即 AIO。在进行 I/O 编程中，通常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务端得到通知，进行相应的处理。</p>
<p>AIO 叫做异步非阻塞的 I/O，引入了异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才会启动线程，特点就是先由操作系统完成后才会通知服务器端程序启动线程去处理，一般用于连接数较多且连接时长较长的应用。</p>
<p>Reactor 和 Proactor</p>
<ul>
<li>两种 IO 多路复用方案：Reactor and Proactor。</li>
<li>Reactor 模式是基于同步 I/O 的，而 Proactor 模式是和异步 I/O 相关的。</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows端口被占用解决方法</title>
    <url>/2021/03/19/Windows%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Error-场景"><a href="#Error-场景" class="headerlink" title="Error 场景"></a>Error 场景</h2><p>启动 Java 项目失败，控制台显示</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Error starting ApplicationContext. To display the conditions report`re-run your application with &#x27;debug&#x27; enabled.</span><br><span class="line"></span><br><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">The Tomcat connector configured to listen on port 8080 failed to start. The port may already be in use or the connector may be misconfigured.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Verify the connector&#x27;s configuration, identify and stop any process that&#x27;s listening on port 8080, or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li><p>查看那些进程占用了我们的端口号<code>8080</code></p>
<p>打开 Windows 控制台，输入命令</p>
</li>
</ul>
<p><code>netstat -nao | findstr &quot;8080&quot;</code></p>
<p>可以看到占用 <code>8080</code> 端口的进程 PID 为 <code>8404</code></p>
<ul>
<li><p>杀死相应进程：</p>
<p>在 Windows 控制台，继续输入命令</p>
</li>
</ul>
<p><code>taskkill /pid 8404 /f</code></p>
<p><img src="https://img.imgdb.cn/item/605440cc524f85ce2903d864.jpg" alt="avatar"></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>端口占用</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoUpdater自动更新客户端</title>
    <url>/2021/03/19/AutoUpdater%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="安装-NuGet-包"><a href="#安装-NuGet-包" class="headerlink" title="安装 NuGet 包"></a>安装 NuGet 包</h2><pre><code>在Visio studio中右击解决方案，选择管理NuGet包，搜索安装Autoupdater.NET.Official。
</code></pre>
<h2 id="工作简介"><a href="#工作简介" class="headerlink" title="工作简介"></a>工作简介</h2><pre><code>    从服务器下载包含更新文件的XML文件，从中获取软件的最新版本信息。如果软件的最新版本大于用户PC上安装的当前软件版本，则会向用户显示更新对话框。当然，也可以设置按钮事件进行点击下载更新文件。如果文件是压缩包，会自动将压缩包的内容解压缩到应用程序目录。
</code></pre>
<h2 id="XML-文件"><a href="#XML-文件" class="headerlink" title="XML 文件"></a>XML 文件</h2><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&gt;</span></span><br><span class="line">&lt; item &gt;</span><br><span class="line">    &lt; version &gt; 2.0.0.0 &lt;/ version &gt;</span><br><span class="line">    &lt; url &gt; https://www.cnblogs.com&lt;/ url &gt;</span><br><span class="line">    &lt; changelog &gt; https://www.cnblogs.com &lt;/ changelog &gt;</span><br><span class="line">    &lt; mandatory &gt; false &lt;/ mandatory &gt;</span><br><span class="line">&lt;/ item &gt;</span><br></pre></td></tr></table></figure>

如上所示：
    version(必填)：格式为X.X.X.X的版本标记。
    url(必填)：最新版本安装程序文件的url。
    changelog(可选)：程序更改日志的url。
    mandatory(可选)：强制更新，将跳过信息和稍后更新按钮隐藏。
选择使用以下代码将跳过update对话框，自动下载更新：

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mandatory</span> <span class="attr">mode</span>=<span class="string">&quot;2&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">mandatory</span>&gt;</span></span><br></pre></td></tr></table></figure>

    args(可选)：为安装提供命令行参数，参数可以包含%path%，用以替换正在执行的应用程序所在目录的路径。
    checksum(可选)：更新文件的校验和，用以检验文件的完整性，algorithm属性指定算法，支持 MD5,SHA1,SHA256,SHA384,SHA512。

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">checksum</span> <span class="attr">algorithm</span>=<span class="string">&quot;MD5&quot;</span>&gt;</span>Update file Checksum<span class="tag">&lt;/<span class="name">checksum</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="窗体代码"><a href="#窗体代码" class="headerlink" title="窗体代码"></a>窗体代码</h2><pre><code><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> AutoUpdaterDotNET;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//XML文件地址</span></span><br><span class="line">            AutoUpdater.Start(<span class="string">&quot;https://www.cnblogs.com&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://github.com/ravibpatel/AutoUpdater.NET">https://github.com/ravibpatel/AutoUpdater.NET</a></p>
]]></content>
      <categories>
        <category>.Net</category>
        <category>Winform</category>
      </categories>
      <tags>
        <tag>AutoUpdater</tag>
        <tag>客户端</tag>
      </tags>
  </entry>
  <entry>
    <title>CefSharp创建客户端</title>
    <url>/2021/03/19/CefSharp%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="安装-NuGet-包"><a href="#安装-NuGet-包" class="headerlink" title="安装 NuGet 包"></a>安装 NuGet 包</h2><pre><code>在Visio studio中右击解决方案，选择管理NuGet包，搜索安装CefSharp.WinForms。
</code></pre>
<h2 id="配置工作"><a href="#配置工作" class="headerlink" title="配置工作"></a>配置工作</h2><pre><code>(1)首先右击项目选择属性，在&quot;生成&quot;选项中将&quot;首选32位&quot;勾上。

(2)其次在项目文件目录下找到&quot;项目名称.csproj&quot;文件，在第一个PropertyGroup中添加以下代码：

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CefSharpAnyCpuSupport</span>&gt;</span>true<span class="tag">&lt;/<span class="name">CefSharpAnyCpuSupport</span>&gt;</span></span><br></pre></td></tr></table></figure>

(3)最后修改App.config文件，和&lt;startup&gt;标签并列地位，添加以下代码：

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">runtime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assemblyBinding</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">probing</span> <span class="attr">privatePath</span>=<span class="string">&quot;x86&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">assemblyBinding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">runtime</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="窗体代码"><a href="#窗体代码" class="headerlink" title="窗体代码"></a>窗体代码</h2><pre><code><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> CefSharp;</span><br><span class="line"><span class="keyword">using</span> CefSharp.WinForms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">embebbedChromium</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> ChromiumWebBrowser chromeBrowser;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            <span class="comment">// 初始化全局组件后启动浏览器</span></span><br><span class="line">            InitializeChromium();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitializeChromium</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CefSettings settings = <span class="keyword">new</span> CefSettings();</span><br><span class="line">            <span class="comment">//按照设置初始化cef</span></span><br><span class="line">            Cef.Initialize(settings);</span><br><span class="line">            <span class="comment">// 创建一个浏览器组件</span></span><br><span class="line">            chromeBrowser = <span class="keyword">new</span> ChromiumWebBrowser(<span class="string">&quot;http://baidu.com&quot;</span>);</span><br><span class="line">            <span class="comment">// 将其添加到表单并将其填充到表单窗口</span></span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(chromeBrowser);</span><br><span class="line">            chromeBrowser.Dock = DockStyle.Fill;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_FormClosing</span>(<span class="params"><span class="built_in">object</span> sender, FormClosingEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Cef.Shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://ourcodeworld.com/articles/read/173/how-to-use-cefsharp-chromium-embedded-framework-csharp-in-a-winforms-application">https://ourcodeworld.com/articles/read/173/how-to-use-cefsharp-chromium-embedded-framework-csharp-in-a-winforms-application</a></p>
]]></content>
      <categories>
        <category>.Net</category>
        <category>Winform</category>
      </categories>
      <tags>
        <tag>客户端</tag>
        <tag>CefSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>WinForm设置控件居中</title>
    <url>/2021/03/19/WinForm%E8%AE%BE%E7%BD%AE%E6%8E%A7%E4%BB%B6%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<h2 id="简单阐述"><a href="#简单阐述" class="headerlink" title="简单阐述"></a>简单阐述</h2><pre><code>在C#的WinForm里面，原生控件是没有居中属性的，故通过重写OnResize(EventArgs e)方法，通过计算，重新定位控件位置。
</code></pre>
<h2 id="以-Label-控件为例"><a href="#以-Label-控件为例" class="headerlink" title="以 Label 控件为例"></a>以 Label 控件为例</h2><pre><code>(1)将label的AutoSize属性设置为false；Dock属性设置为fill；TextAlign属性设置为MiddleCenter。
(2)重写居中的代码如下：
</code></pre>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResize</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnResize(e);</span><br><span class="line">            <span class="built_in">int</span> x = (<span class="built_in">int</span>)(<span class="number">0.5</span> * (<span class="keyword">this</span>.Width - label1.Width));</span><br><span class="line">            <span class="built_in">int</span> y = label1.Location.Y;</span><br><span class="line">            label1.Location = <span class="keyword">new</span> System.Drawing.Point(x,y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://blog.csdn.net/mingyueyixi/article/details/55035935">https://blog.csdn.net/mingyueyixi/article/details/55035935</a></p>
]]></content>
      <categories>
        <category>.Net</category>
        <category>Winform</category>
      </categories>
      <tags>
        <tag>控件</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Batch学习笔记（一）</title>
    <url>/2021/03/19/Spring-Batch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Spring-Batch-简介"><a href="#Spring-Batch-简介" class="headerlink" title="Spring Batch 简介"></a>Spring Batch 简介</h2><p>Spring Batch 提供了可重复使用的功能，用来处理大量数据。包括记录、跟踪，事务管理，作业处理统计，作业重启，跳过和资源管理。<br>此外还提供了更高级的技术服务和功能，通过优化和分区技术实现极高容量和高性能的批处理作业。</p>
<h2 id="Spring-Batch-使用场景"><a href="#Spring-Batch-使用场景" class="headerlink" title="Spring Batch 使用场景"></a>Spring Batch 使用场景</h2><p>(1)一般的批处理程序</p>
<p>·从数据库，文件或者队列中读取大量数据<br>·处理读取到的数据<br>·将处理完成的数据保存到文件，数据库</p>
<p>(2)业务场景</p>
<p>·定期提交批处理<br>·并发批处理，并行处理 Job<br>·分阶段的企业消息驱动处理<br>·大规模并行批处理<br>·失败后手动或预定重启<br>·依赖步骤的顺序处理<br>·部分处理，跳过记录<br>·整批交易，适用于批量较小或现有存储过程/脚本的情况</p>
<h2 id="Spring-Batch-主要组成部分"><a href="#Spring-Batch-主要组成部分" class="headerlink" title="Spring Batch 主要组成部分"></a>Spring Batch 主要组成部分</h2><p>·JobRepository，用来注册 job 的容器<br>·JobLauncher，用来启动 job 的接口<br>·Job，实际执行的任务，包含一个或多个 Step<br>·Step，step 包含 ItemReader、ItemProcessor 和 ItemWriter<br>·ItemReader，用来读取数据的接口<br>·ItemProcessor，用来处理数据的接口<br>·ItemWriter，用来输出数据的接口<br>以上 Spring Batch 的主要组成部分只需要注册成 Spring 的 Bean 即可。批处理的配置类上需要使用@EnabelBatchProcessing。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>(1)监听器 JobListener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobListener</span> <span class="keyword">implements</span> <span class="title">JobExecutionListener</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeJob</span><span class="params">(JobExecution jobExecution)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Job执行前需要执行的操作</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterJob</span><span class="params">(JobExecution jobExecution)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Job执行完成后需要执行的操作</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)配置类 DataBatchConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBatchConfiguration</span></span>&#123;</span><br><span class="line"> <span class="comment">// 用于构建Job</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> JobBuilderFactory jobBuilderFactory;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 用于构建Step</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> StepBuilderFactory stepBuilderFactory;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 监听器</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> JobListener jobListener;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ItemReader(使用的其中一种读取方式)</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> RepositoryItemReader readerData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ItemWriter</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> ItemReader writerData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Job</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Job <span class="title">dataHandleJob</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> jobBuilderFactory.get(<span class="string">&quot;dataHandleJob&quot;</span>).incrementer(<span class="keyword">new</span> RunIdIncrementer()).start(getDataStep())</span><br><span class="line">   .listener(jobListener).build();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Step</span></span><br><span class="line"> <span class="comment">// User:要处理的对象</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Step <span class="title">getTDistSellOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> stepBuilderFactory.get(<span class="string">&quot;getData&quot;</span>).&lt;User, User&gt;chunk(<span class="number">10000</span>) <span class="comment">// 一次commit数据的数量</span></span><br><span class="line">   .faultTolerant().retryLimit(<span class="number">3</span>)</span><br><span class="line">   .retry(Exception.class)</span><br><span class="line">   .skipLimit(<span class="number">100</span>)            <span class="comment">// 发生异常时，允许重试的次数</span></span><br><span class="line">   .skip(Exception.class)</span><br><span class="line">   .reader(readerData)              <span class="comment">// reader</span></span><br><span class="line">   .writer(writerData).build();        <span class="comment">// writer</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)读取类 ReaderStep</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderStep</span></span>&#123;</span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> EntityManagerFactory emf;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span> <span class="function">RepositoryItemReader&lt;User&gt; <span class="title">readerData</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 排序map(读取数据按照ID进行正序排列)</span></span><br><span class="line">  Map&lt;String,Sort.Direction&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;id&quot;</span>,sort.Direction.ASC);</span><br><span class="line">  <span class="comment">// SQL语句所需参数LIST</span></span><br><span class="line">  List&lt;String&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  params.add(<span class="string">&quot;2019-03-20&quot;</span>);</span><br><span class="line">  RepositoryItemReader&lt;User&gt; repositoryItemReader = <span class="keyword">new</span> <span class="keyword">new</span> RepositoryItemReader&lt;&gt;();</span><br><span class="line">  <span class="comment">// Set Repository</span></span><br><span class="line">  repositoryItemReader.setRepository(userRepository);</span><br><span class="line">  <span class="comment">// Set PageSize(没有会报错)</span></span><br><span class="line">  repositoryItemReader.setPageSize(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">// Set Repository Method</span></span><br><span class="line">  repositoryItemReader.setMethodName(<span class="string">&quot;findByDateLike&quot;</span>);</span><br><span class="line">  <span class="comment">// Set 参数List</span></span><br><span class="line">  repositoryItemReader.setArguments(params);</span><br><span class="line">  <span class="comment">// Set 排序Map</span></span><br><span class="line">  repositoryItemReader.setSort(map);</span><br><span class="line">  <span class="keyword">return</span> repositoryItemReader;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)写出类 WriterStep</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterStep</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RepositoryItemWriter&lt;User&gt; <span class="title">writerData</span><span class="params">()</span></span>&#123;</span><br><span class="line">  RepositoryItemWriter&lt;User&gt; repositoryItemWriter = <span class="keyword">new</span> RepositoryItemWriter&lt;&gt;();</span><br><span class="line">  repositoryItemWriter.setRepository(userRepository);</span><br><span class="line">  repositoryItemWriter.setMethodName(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> repositoryItemWriter;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><p><a href="https://www.cnblogs.com/ealenxie/p/9647703.html">https://www.cnblogs.com/ealenxie/p/9647703.html</a></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Batch</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类型转换工具类（持续更新）</title>
    <url>/2021/03/19/Java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  将项目中用到的类型转换做个记录。</p>
<h2 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeUtil</span> </span>&#123;</span><br><span class="line"> <span class="comment">// [start]字符串转各种格式</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转日期(格式:&quot;yyyyMMdd&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">StrToDateFirst</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">  Date date = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   date = format.parse(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转日期(格式:&quot;dd/MM/yyyy&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">StrToDateSecond</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;dd/MM/yyyy&quot;</span>);</span><br><span class="line">  Date date = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   date = format.parse(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转日期(格式:&quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">StrToDateThird</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">  Date date = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   date = format.parse(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转日期(格式:&quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">StrToDateFourth</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">  Date date = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   date = format.parse(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转Integer</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">StrToInteger</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  Integer integer = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   integer = Integer.valueOf(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> integer;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转Double</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">StrToDouble</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  Double double1 = <span class="number">0.00</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   double1 = Double.parseDouble(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> double1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转时间戳</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Timestamp <span class="title">StrToTimeStamp</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  Timestamp timestamp = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   timestamp = Timestamp.valueOf(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> timestamp;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 字符串转BigDecimal</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">StrTiBigdecimal</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  BigDecimal bigDecimal = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   bigDecimal = <span class="keyword">new</span> BigDecimal(str);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bigDecimal;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// [end]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
        <tag>Utils</tag>
      </tags>
  </entry>
  <entry>
    <title>维护java项目之==和equals</title>
    <url>/2021/03/19/%E7%BB%B4%E6%8A%A4java%E9%A1%B9%E7%9B%AE%E4%B9%8B-%E5%92%8Cequals/</url>
    <content><![CDATA[<p>最近发生一件很尴尬的事情，在维护一个 Java 项目的时候，发现有使用 <code>==</code> 来比较两个对象的属性，<br>于是顺手就把 <code>==</code> 改成了 equals。悲剧发生……🤣🤣🤣</p>
<h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals 的区别"></a><code>==</code> 和 equals 的区别</h2><p><code>==</code> ：对于基本类型来说是值比较，对于引用类型来说是引用比较<br>equals：引用比较，但一些类重写了 equals 方法，如 String、Integer 等，变成了值比较。</p>
<h2 id="使用-equals-的前提"><a href="#使用-equals-的前提" class="headerlink" title="使用 equals 的前提"></a>使用 equals 的前提</h2><p>使用 equals 进行比较，如：<br>a 和 b 是两个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.getId().equals(b.getId())</span><br></pre></td></tr></table></figure>

<p>需要确保 a.getId()不为 null，因为 null 是没有.equals()方法的。</p>
<h2 id="各种对象使用-equals"><a href="#各种对象使用-equals" class="headerlink" title="各种对象使用 equals"></a>各种对象使用 equals</h2><p>String 类型：<br>可以使用 StringUtils.equals()进行比较，该方法内置非空校验<br>其余封装类型：<br>可以使用 Objects.equals()进行比较，该方法内置非空校验<br>使用三目运算符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.getId() == <span class="keyword">null</span> ? b.getId() == <span class="keyword">null</span> ? <span class="keyword">false</span> : <span class="keyword">true</span> : a.getId().equals(b.getId())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title>一款智能的日期解析工具</title>
    <url>/2021/03/19/%E4%B8%80%E6%AC%BE%E6%99%BA%E8%83%BD%E7%9A%84%E6%97%A5%E6%9C%9F%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Java</code> 中日期、时间相关的类相当的多，并且分不同的版本提供了不同的实现，包括 <code>Date</code> 、 <code>Calendar</code> 、 <code>LocalDateTime</code> 、 <code>ZoneDateTime</code> 、 <code>OffsetDateTime</code> 等等。针对这些时间类型又通过 <code>SimpleDateFormat</code> 和 <code>DateTimeFormatter</code> 实现不同的日期与字符串之间的格式化和解析。</p>
<p>为了应对各种各样的日期解析，我们通常会封装类似于 <code>DateUtils</code> 的工具类，专门用来处理日期字符串的解析，同时为了兼容不同格式的日期字符串，又需要预先枚举出可能用到的日期格式。这种传统的 <code>DateUtils</code> 通常会面临性能与兼容性的两难问题。</p>
<p>而本文要介绍的，是一个截然不同的日期解析工具 <code>dateparser</code> ，它可以智能地解析几百上千种任意格式的日期字符串，更为难得的是它的性能同样非常出色。</p>
<h2 id="DateUtils-的两难问题"><a href="#DateUtils-的两难问题" class="headerlink" title="DateUtils 的两难问题"></a>DateUtils 的两难问题</h2><p>一个比较典型的日期解析函数类似这样（这是 <code>commons-lang3</code> 在其 <code>DateUtils</code> 中提供的函数）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">parseDate</span><span class="params">(<span class="keyword">final</span> String str, <span class="keyword">final</span> String... parsePatterns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseDate(str, <span class="keyword">null</span>, parsePatterns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种日期解析函数的内部逻辑，往往是根据一批 <code>DATE_FORMAT</code> 轮番尝试，通过异常重试的方式试出来唯一匹配的格式。这种简单粗暴的方式，事实上存在着一个两难问题。</p>
<p>首先，我们很难穷举出全部可能出现的日期格式，年月日的分隔符、排列次序、时分秒、是否有毫秒、时区处理、PM 与 AM 的支持等等，罗列出来的话不计其数。</p>
<p>其次，异常重试的方式存在一些性能损耗，据我粗略测算，在 MBP 硬件环境中异常中断大概需要消耗 <code>2</code> 微秒，而一次日期解析可能消耗 <code>0.75</code> 微秒。如果提供的 <code>parsePatterns</code> 数量很多，则解析一个日期字符串的循环重试的最终耗时甚至会超过 <code>Redis</code> 读写操作。</p>
<p>那么，有没有办法既可以支持无数多个不规则的日期字符串，同时也没有性能问题的技术方案呢？</p>
<h2 id="dateparser"><a href="#dateparser" class="headerlink" title="dateparser"></a><code>dateparser</code></h2><p>这就是解决日期字符串解析的灵丹妙药，它是一个高性能且非常智能的 datetime 字符串解析工具。</p>
<p>为了实现高性能与可扩展性，它并没有采用 <code>SimpleDateFormat</code> 或 <code>DateTimeFormatter</code> ，而是正则表达式。通过预定义的正则表达式来自动地捕捉不同格式的日期片段，它可以自动抽取出字符串中存在的 <code>year</code> , <code>month</code> , <code>day</code> , <code>hour</code> , <code>minute</code> , <code>second</code> , <code>zone</code> 等熟悉。</p>
<p>这些预定义的正则表达式片段包括：</p>
<p><code>(?&lt;week&gt;%s)\W*</code> 可以将 <code>Monday</code> 解析为 <code>week</code></p>
<p><code>?(?&lt;year&gt;\d&#123;4&#125;)$</code> 可以将 <code>2019</code> 解析为 <code>year</code></p>
<p><code>^(?&lt;year&gt;\d&#123;4&#125;)(?&lt;month&gt;\d&#123;2&#125;)$</code> 可以抽取出 <code>201909</code> 内部的 <code>year</code> 和 <code>month</code></p>
<p><code>?(?&lt;hour&gt;\d&#123;1,2&#125;) o’clock\W*</code> 可以将 <code>12 o’clock</code> 解析为 <code>hour</code></p>
<p>更多规则参见 <code>DateParserBuilder.java</code></p>
<p>如此多的正则表达式，会不会也存在性能隐患呢？如果使用的是 <code>java.util.regex</code> 包来进行循环匹配，随着规则增加，确实会有性能问题。<br>但是 <code>dateparser</code> 使用 <code>retree</code> 将预定义的一大批正则表达式合并为一颗树，也就是正则匹配树。它可以非常快速地对一大批正则表达式执行并行匹配，内部结构可以理解为字典树，但是树中的节点并不是字母，而是正则匹配节点。</p>
<h2 id="安装-Maven-依赖"><a href="#安装-Maven-依赖" class="headerlink" title="安装 Maven 依赖"></a>安装 Maven 依赖</h2><p>可以通过此 <code>maven</code> 坐标引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.sisyphsu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dateparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><code>dateparser</code> 提供了一个 <code>DateParserUtils</code> 工具类，可以直接使用它将字符串解析为 <code>Date</code> 、 <code>Calendar</code> 、 <code>LocalDateTime</code> 、 <code>OffsetDateTime</code> 等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = DateParserUtils.parseDate(<span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span>);</span><br><span class="line"><span class="comment">// Tue Jan 03 06:04:05 CST 2006</span></span><br><span class="line">Calendar calendar =</span><br><span class="line">DateParserUtils.parseCalendar(<span class="string">&quot;Fri Jul 03 2015 18:04:07 GMT+0100 (GMT Daylight Time)&quot;</span>);</span><br><span class="line"><span class="comment">// 2015-07-03T17:04:07Z</span></span><br><span class="line">LocalDateTime dateTime =</span><br><span class="line">DateParserUtils.parseDateTime(<span class="string">&quot;2019-09-20 10:20:30.12345678 +0200&quot;</span>);</span><br><span class="line"><span class="comment">// 2019-09-20T16:20:30.123456780</span></span><br><span class="line">OffsetDateTime offsetDateTime =</span><br><span class="line">DateParserUtils.parseOffsetDateTime(<span class="string">&quot;2015-09-30 18:48:56.35272715 +0000 UTC&quot;</span>);</span><br><span class="line"><span class="comment">// 2015-09-30T18:48:56.352727150Z</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，它会根据字符串中标明的 <code>TimeZon</code> e 或 <code>ZoneOffset</code> 自动进行偏移量转换。</p>
<h2 id="创建新-DateParser-实例"><a href="#创建新-DateParser-实例" class="headerlink" title="创建新 DateParser 实例"></a>创建新 DateParser 实例</h2><p>由于 <code>DateParser</code> 不是线程安全的，同时 <code>parse</code> 操作通常非常快速（1us），因此 <code>DateParserUtils</code> 内部直接维护了一个 <code>DateParser</code> 单例，然后通过 <code>synchronized</code> 进行并发控制。</p>
<p>如果你想在多线程中高频率、并发地使用它，就应该为不同的线程创建不同的 <code>DateParser</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateParser parser = DateParser.newBuilder().build();</span><br><span class="line">Date date = parser.parseDate(<span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span>);</span><br><span class="line"><span class="comment">// Tue Jan 03 06:04:05 CST 2006</span></span><br></pre></td></tr></table></figure>

<p><code>DateParser</code> 实例相当笨重一些，所以你应该尽量多的复用它以提高性能。</p>
<h2 id="MM-dd-与-dd-MM-的优先级"><a href="#MM-dd-与-dd-MM-的优先级" class="headerlink" title="MM/dd 与 dd/MM 的优先级"></a><code>MM/dd</code> 与 <code>dd/MM</code> 的优先级</h2><p>多数情况下， <code>dateparser</code> 可以按照规则自动地识别出字符串内部的 <code>month</code> 与 <code>day</code> 片段。</p>
<p>但是对于 <code>MM/dd/yy</code> 和 <code>dd/MM/yy</code> ，有时候它就难以区分了。因为世界上多数国家会使用 <code>dd/MM/yy</code> 作为日期的格式，但是也有少数国家会特立独行地使用 <code>MM/dd/yy</code> 作为日期格式，最典型的就是美帝国主义。</p>
<p>因此当 <code>dateparser</code> 遇到类似于 <code>7.8.2019</code> 这样的日期时，它就很难判断到底是 7 月 8 日还是 8 月 7 日。</p>
<p>为解决这个难题， <code>dateparser</code> 内部增加了一个名为 <code>preferMonthFirst</code> 的选项，用于辅助解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateParserUtils.preferMonthFirst(<span class="keyword">true</span>);</span><br><span class="line">DateParserUtils.parseCalendar(<span class="string">&quot;08.03.71&quot;</span>);</span><br><span class="line"><span class="comment">// 1971-08-03</span></span><br><span class="line">DateParserUtils.preferMonthFirst(<span class="keyword">false</span>);</span><br><span class="line">DateParserUtils.parseCalendar(<span class="string">&quot;08.03.71&quot;</span>);</span><br><span class="line"><span class="comment">// 1971-03-08</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，如果无法甄别月与日，则视为月在后。如果你指定了 <code>preferMonthFirst</code> 为 <code>true</code> ，则试为月在前。</p>
<h2 id="自定义-Parser"><a href="#自定义-Parser" class="headerlink" title="自定义 Parser"></a>自定义 Parser</h2><p>你可以使用 <code>DateParserBuilder</code> 构建自己的日期解析器，通过此 <code>builder</code> ，你可以自定义新的解析规则。</p>
<p>例如，如果你想支持 <code>【2019】</code> 这样的 <code>year</code> 字符串，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateParser parser = DateParser.newBuilder().addRule(<span class="string">&quot;【(?&lt;year&gt;\\d&#123;4&#125;)】&quot;</span>).build();</span><br><span class="line">Calendar calendar = parser.parseCalendar(<span class="string">&quot;【1991】&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span> calendar.get(Calendar.YEAR) == <span class="number">1991</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，正则表达式 <code>【(?&lt;year&gt;\\d&#123;4&#125;)】</code> 里面的 <code>year</code> 非常重要，它是 <code>dateparser</code> 内置的捕捉关键词。</p>
<p>你也可以增加更加灵活的解析规则，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateParser parser = DateParser.newBuilder()</span><br><span class="line">.addRule(<span class="string">&quot;民国(\\d&#123;3&#125;)年&quot;</span>, (input, matcher, dt) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> offset = matcher.start(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i0 = input.charAt(offset) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> i1 = input.charAt(offset + <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = input.charAt(offset + <span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dt.setYear(i0 * <span class="number">100</span> + i1 * <span class="number">10</span> + i2 + <span class="number">1911</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.build();</span><br><span class="line">Calendar calendar = parser.parseCalendar(<span class="string">&quot;民国101年&quot;</span>);</span><br><span class="line"><span class="keyword">assert</span> calendar.get(Calendar.YEAR) == <span class="number">2012</span>;</span><br></pre></td></tr></table></figure>

<p>这个例子里面，新增了一个捕捉并解析 <code>民国xxx年</code> 的日期规则。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>首先，在单一日期格式下，对比一下 <code>dateparser</code> 与 <code>SimpleDateFormat</code> 的性能表现：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Benchmark               Mode  Cnt     Score    Error  Units</span><br><span class="line">SingleBenchmark.java    avgt    6   921.632 ± 12.299  ns/op</span><br><span class="line">SingleBenchmark.parser  avgt    6  1553.909 ± 70.664  ns/op</span><br></pre></td></tr></table></figure>

<p>可以看到，在日期格式固定且单一的情况下， <code>dateparser</code> 在性能上处于下风，这也在预料之中。</p>
<p>然后，在单一日期格式下，对比一下 <code>dateparser</code> 与 <code>DateTimeFormatter</code> 的性能表现：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Benchmark                       Mode  Cnt     Score    Error  Units</span><br><span class="line">SingleDateTimeBenchmark.java    avgt    6   654.553 ± 16.703  ns/op</span><br><span class="line">SingleDateTimeBenchmark.parser  avgt    6  1680.690 ± 34.214  ns/op</span><br></pre></td></tr></table></figure>

<p>可以看到， <code>DateTimeFormatter</code> 的性能表现确实比 S <code>impleDateFormat</code> 更加出色一些。同时 dateparser 的设计初衷是为了应对不规则日期格式，因此在固定格式匹配上存在劣势并不意外。</p>
<p>如果我们将日期格式增加为 16 种时，性能表现就不一样了：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Benchmark              Mode  Cnt      Score      Error  Units</span><br><span class="line">MultiBenchmark.format  avgt    6  47385.021 ± 1083.649  ns/op</span><br><span class="line">MultiBenchmark.parser  avgt    6  22852.113 ±  310.720  ns/op</span><br></pre></td></tr></table></figure>

<p>如果换算一下，无论日期格式是一种还是 16 中， <code>dateparser</code> 的性能始终维持在 <code>1.5us</code> ，说明它在算法上是非常稳定的，面对不同的场景不会有什么性能损失</p>
<h2 id="支持的日期格式（部分）"><a href="#支持的日期格式（部分）" class="headerlink" title="支持的日期格式（部分）"></a>支持的日期格式（部分）</h2><p>以下为 <code>dateparser</code> 在单元测试中完成测试解析的日期格式样例，具体可以参考源代码。同时需要注意的是，这个列表只是一个子集：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">May 8, 2009 5:57:51 PM</span><br><span class="line">oct 7, 1970</span><br><span class="line">oct 7, &#x27;70</span><br><span class="line">oct. 7, 1970</span><br><span class="line">oct. 7, 70</span><br><span class="line">Mon Jan  2 15:04:05 2006</span><br><span class="line">Mon Jan  2 15:04:05 MST 2006</span><br><span class="line">Mon Jan 02 15:04:05 -0700 2006</span><br><span class="line">Monday, 02-Jan-06 15:04:05 MST</span><br><span class="line">Mon, 02 Jan 2006 15:04:05 MST</span><br><span class="line">Tue, 11 Jul 2017 16:28:13 +0200 (CEST)</span><br><span class="line">Mon, 02 Jan 2006 15:04:05 -0700</span><br><span class="line">Thu, 4 Jan 2018 17:53:36 +0000</span><br><span class="line">Mon Aug 10 15:44:11 UTC+0100 2015</span><br><span class="line">Fri Jul 03 2015 18:04:07 GMT+0100 (GMT Daylight Time)</span><br><span class="line">September 17, 2012 10:09am</span><br><span class="line">September 17, 2012 at 10:09am PST-08</span><br><span class="line">September 17, 2012, 10:10:09</span><br><span class="line">October 7, 1970</span><br><span class="line">October 7th, 1970</span><br><span class="line">12 Feb 2006, 19:17</span><br><span class="line">12 Feb 2006 19:17</span><br><span class="line">7 oct 70</span><br><span class="line">7 oct 1970</span><br><span class="line">03 February 2013</span><br><span class="line">1 July 2013</span><br><span class="line">2013-Feb-03</span><br><span class="line">3/31/2014</span><br><span class="line">03/31/2014</span><br><span class="line">08/21/71</span><br><span class="line">8/1/71</span><br><span class="line">4/8/2014 22:05</span><br><span class="line">04/08/2014 22:05</span><br><span class="line">4/8/14 22:05</span><br><span class="line">04/2/2014 03:00:51</span><br><span class="line">8/8/1965 12:00:00 AM</span><br><span class="line">8/8/1965 01:00:01 PM</span><br><span class="line">8/8/1965 01:00 PM</span><br><span class="line">8/8/1965 1:00 PM</span><br><span class="line">8/8/1965 12:00 AM</span><br><span class="line">4/02/2014 03:00:51</span><br><span class="line">03/19/2012 10:11:59</span><br><span class="line">03/19/2012 10:11:59.3186369</span><br><span class="line">2014/3/31</span><br><span class="line">2014/03/31</span><br><span class="line">2014/4/8 22:05</span><br><span class="line">2014/04/08 22:05</span><br><span class="line">2014/04/2 03:00:51</span><br><span class="line">2014/4/02 03:00:51</span><br><span class="line">2012/03/19 10:11:59</span><br><span class="line">2012/03/19 10:11:59.3186369</span><br><span class="line">2014年04月08日</span><br><span class="line">2006-01-02T15:04:05+0000</span><br><span class="line">2009-08-12T22:15:09-07:00</span><br><span class="line">2009-08-12T22:15:09</span><br><span class="line">2009-08-12T22:15:09Z</span><br><span class="line">2014-04-26 17:24:37.3186369</span><br><span class="line">2012-08-03 18:31:59.257000000</span><br><span class="line">2014-04-26 17:24:37.123</span><br><span class="line">2013-04-01 22:43</span><br><span class="line">2013-04-01 22:43:22</span><br><span class="line">2014-12-16 06:20:00 UTC</span><br><span class="line">2014-12-16 06:20:00 GMT</span><br><span class="line">2014-04-26 05:24:37 PM</span><br><span class="line">2014-04-26 13:13:43 +0800</span><br><span class="line">2014-04-26 13:13:43 +0800 +08</span><br><span class="line">2014-04-26 13:13:44 +09:00</span><br><span class="line">2012-08-03 18:31:59.257000000 +0000 UTC</span><br><span class="line">2015-09-30 18:48:56.35272715 +0000 UTC</span><br><span class="line">2015-02-18 00:12:00 +0000 GMT</span><br><span class="line">2015-02-18 00:12:00 +0000 UTC</span><br><span class="line">2015-02-08 03:02:00 +0300 MSK m=+0.000000001</span><br><span class="line">2015-02-08 03:02:00.001 +0300 MSK m=+0.000000001</span><br><span class="line">2017-07-19 03:21:51+00:00</span><br><span class="line">2014-04-26</span><br><span class="line">2014-04</span><br><span class="line">2014</span><br><span class="line">2014-05-11 08:20:13,787</span><br><span class="line">3.31.2014</span><br><span class="line">03.31.2014</span><br><span class="line">08.21.71</span><br><span class="line">2014.03</span><br><span class="line">2014.03.30</span><br><span class="line">20140601</span><br><span class="line">20140722105203</span><br><span class="line">1332151919</span><br><span class="line">1384216367189</span><br><span class="line">1384216367111222</span><br><span class="line">1384216367111222333</span><br></pre></td></tr></table></figure>

<h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p>本文转载至<a href="https://sulin.me/2019/38Z4HAT.html">https://sulin.me/2019/38Z4HAT.html</a></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Utils</tag>
        <tag>日期解析</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2021/03/18/about/</url>
    <content><![CDATA[<h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul>
<li>张凯/男/1996</li>
<li>本科/淮阴工学院（计算机科学与技术专业）</li>
<li>工作年限：3 年</li>
<li>技术博客：<a href="https://zhkaif.github.io/">https://zhkaif.github.io/</a></li>
<li>期望职位：Java 开发</li>
<li>期望薪资：税前月薪 15K~20K，特别喜欢的公司或者徐州可谈</li>
<li>期望城市：南京或徐州</li>
</ul>
<h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul>
<li>手机：13182353591</li>
<li>邮箱：<a href="mailto:&#x32;&#53;&#x37;&#x32;&#x34;&#50;&#57;&#x32;&#x33;&#x35;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x32;&#53;&#x37;&#x32;&#x34;&#50;&#57;&#x32;&#x33;&#x35;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a></li>
<li>QQ/微信手机号：2572429235/13182353591</li>
</ul>
<h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><p>南京联迪信息股份有限公司（2018 年 6 月~至今）</p>
<h3 id="3M-POS-数据收集系统（2020-年-10-月-至今）"><a href="#3M-POS-数据收集系统（2020-年-10-月-至今）" class="headerlink" title="3M POS 数据收集系统（2020 年 10 月~至今）"></a>3M POS 数据收集系统（2020 年 10 月~至今）</h3><p>帮助 3M 公司使用系统自动处理经销商的销售数据。<br>包括对数据的自动定时抽取上传、校验、转换等基础，以及错误数据回滚、经销商管理、日志管理等配套功能。</p>
<h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h4><ul>
<li>WEB 端的金税抽取规则设置功能、数据回滚功能、客户端版本管理功能的前后端开发。</li>
<li>客户端开发，包括数据定时自动抽取、根据 WEB 页面配置的规则进行数据校验和过滤、指定时间的数据补抓重抓、客户端自动更新功能。</li>
<li>经销商上线的对接，远程指导经销商安装客户端配置定时抓取任务。</li>
<li>系统操作手册和客户端安装手册的编写。</li>
<li>系统后续功能的开发和运维工作。</li>
</ul>
<h4 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h4><h5 id="使用技术"><a href="#使用技术" class="headerlink" title="使用技术"></a>使用技术</h5><ul>
<li>WEB：Vue + Element-ui</li>
<li>API：SpringBoot + Jpa + Hibernate + Swagger</li>
<li>数据库：SQLSERVER</li>
<li>客户端：Winform + Cefsharp</li>
<li>此外，安装过程中对 Windows 系统的了解加深，任务计划程序在各种操作系统的配置、管理员权限的配置和取得、多种防护软件的设置。</li>
</ul>
<h5 id="业绩成果"><a href="#业绩成果" class="headerlink" title="业绩成果"></a>业绩成果</h5><p>目前已经成功上线 7 家经销商，后续上线正则有序进行，2021 年计划上线 100 家经销商。</p>
<h3 id="ANA-航空到着案内（2019-年-11-月-2020-年-6-月）"><a href="#ANA-航空到着案内（2019-年-11-月-2020-年-6-月）" class="headerlink" title="ANA 航空到着案内（2019 年 11 月~2020 年 6 月）"></a>ANA 航空到着案内（2019 年 11 月~2020 年 6 月）</h3><p>面向 ANA 航空公司的乘客提供航班查询以及提示等服务的 PWA 应用。</p>
<ul>
<li>在线查询航班并将所查航班信息发送到邮箱服务</li>
<li>个人航班履历查询功能，安装已乘坐和未乘坐进行分类展示。</li>
<li>航班提示功能，包括邮箱提示和网页通过操作系统发起的提示。</li>
<li>航空公司新闻和注意事项提示信息的展示</li>
<li>Web 端管理新闻和注意事项</li>
</ul>
<h4 id="职责-1"><a href="#职责-1" class="headerlink" title="职责"></a>职责</h4><ul>
<li>后台管理系统的前后端开发，对 PWA 提供的航空新闻和注意事项以及乘客的反馈进行管理。</li>
<li>航班查询页面的开发。</li>
<li>为适应手机、平板、WEB 对多个页面进行调整。</li>
<li>测试式样书的编写。</li>
</ul>
<h4 id="项目总结-1"><a href="#项目总结-1" class="headerlink" title="项目总结"></a>项目总结</h4><h5 id="使用技术-1"><a href="#使用技术-1" class="headerlink" title="使用技术"></a>使用技术</h5><ul>
<li>WEB：Kony + Node.js</li>
<li>API：JavaService</li>
<li>数据库：Mysql</li>
<li>收获：进一步理解了 Kony 的开发生态圈，并通过 Kony 的云平台发布后端的 API，很便捷。</li>
</ul>
<h3 id="爬虫开发与部署"><a href="#爬虫开发与部署" class="headerlink" title="爬虫开发与部署"></a>爬虫开发与部署</h3><p>使用 Scrapy 框架对 Nikkei、中商情报网、Yahoo 以及 3GPP 等网站进行数据的爬取，并发布到 Crawlab 平台进行定时执行。</p>
<h3 id="职责-2"><a href="#职责-2" class="headerlink" title="职责"></a>职责</h3><ul>
<li>Nikkei 爬虫、中商情报网爬虫、Yahoo 爬虫、3GPP 爬虫的编写</li>
<li>爬虫发布到部署好的 Crawlab 定期执行</li>
<li>3GPP 爬虫运行情况以及爬取数据 Size 的邮箱通知功能</li>
</ul>
<h4 id="项目总结-2"><a href="#项目总结-2" class="headerlink" title="项目总结"></a>项目总结</h4><h5 id="使用技术-2"><a href="#使用技术-2" class="headerlink" title="使用技术"></a>使用技术</h5><ul>
<li>爬虫：Python + Scrapy</li>
<li>数据库：MongoDB + ElasticSearch + Redis</li>
<li>发布平台：crawlab</li>
<li>收获：更熟悉 Python，学会了多种存储方式以及各自的优势。反爬虫的初步了解和应对方法。</li>
</ul>
<h3 id="ElasticSearch-管理及新闻检索平台"><a href="#ElasticSearch-管理及新闻检索平台" class="headerlink" title="ElasticSearch 管理及新闻检索平台"></a>ElasticSearch 管理及新闻检索平台</h3><p>将 ElasticSearch 的查询文档、创建索引、更新索引、索引的分词和同义词设置等 API 通过界面进行可视化操作。</p>
<h3 id="职责-3"><a href="#职责-3" class="headerlink" title="职责"></a>职责</h3><p>整个项目的搭建和前后台开发。</p>
<h4 id="项目总结-3"><a href="#项目总结-3" class="headerlink" title="项目总结"></a>项目总结</h4><h5 id="使用技术-3"><a href="#使用技术-3" class="headerlink" title="使用技术"></a>使用技术</h5><ul>
<li>WEB：Vue + Elemen-ui</li>
<li>API：Python + FastApi</li>
<li>数据库：Mysql + ElasticSearch</li>
<li>收获：加深了对于ES的了解和使用，学会了使用FastApi进行后台的开发。</li>
</ul>
<h2 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h2><ul>
<li>开发语言：Java/C#/Python</li>
<li>前端框架：Vue</li>
<li>数据库相关：MySQL/SQLSERVER/MongoDB/ES</li>
<li>版本管理：Git/Svn</li>
<li>单元测试：Junit/Pytest</li>
<li>开发工具：Idea/STS/VsCode</li>
</ul>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue函数防抖和函数节流</title>
    <url>/2021/03/18/Vue%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</li>
<li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li>
<li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li>
</ul>
<h3 id="实现方法，防抖重在清零"><a href="#实现方法，防抖重在清零" class="headerlink" title="实现方法，防抖重在清零"></a>实现方法，防抖重在清零</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            f(..args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><code>scroll</code>事件，每隔一秒计算一次位置信息等</li>
<li>浏览器播放事件，每隔一秒计算一次进度信息等</li>
<li>input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求</li>
</ul>
<h4 id="实现方法，节流重在开关锁"><a href="#实现方法，节流重在开关锁" class="headerlink" title="实现方法，节流重在开关锁"></a>实现方法，节流重在开关锁</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">f, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">..args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            f(..args)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误触发多次。代码重在清零<code>clearTimeout</code></li>
<li>节流：控制流量，单位时间内事件只能触发一次，如果服务器端的限流即 Rate Limit。代码实现重在开锁关锁<code>timer=timeout；timer=null</code></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
</search>
